import {
  Keypair,
  PublicKey,
  SYSVAR_RENT_PUBKEY,
  SystemProgram,
  Transaction,
  TransactionInstruction,
  index_browser_esm_exports,
  init_index_browser_esm,
  require_base64_js,
  require_bn,
  require_bs58,
  require_ieee754,
  require_lib,
  sendAndConfirmTransaction
} from "./chunk-FPF4Y7UI.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/constants.js
var require_constants = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenStandard = exports.UseMethod = exports.MetadataKey = void 0;
    var MetadataKey;
    (function(MetadataKey2) {
      MetadataKey2[MetadataKey2["Uninitialized"] = 0] = "Uninitialized";
      MetadataKey2[MetadataKey2["MetadataV1"] = 4] = "MetadataV1";
      MetadataKey2[MetadataKey2["EditionV1"] = 1] = "EditionV1";
      MetadataKey2[MetadataKey2["MasterEditionV1"] = 2] = "MasterEditionV1";
      MetadataKey2[MetadataKey2["MasterEditionV2"] = 6] = "MasterEditionV2";
      MetadataKey2[MetadataKey2["EditionMarker"] = 7] = "EditionMarker";
      MetadataKey2[MetadataKey2["UseAuthorityRecord"] = 8] = "UseAuthorityRecord";
      MetadataKey2[MetadataKey2["CollectionAuthorityRecord"] = 9] = "CollectionAuthorityRecord";
    })(MetadataKey = exports.MetadataKey || (exports.MetadataKey = {}));
    var UseMethod;
    (function(UseMethod2) {
      UseMethod2[UseMethod2["Burn"] = 0] = "Burn";
      UseMethod2[UseMethod2["Single"] = 1] = "Single";
      UseMethod2[UseMethod2["Multiple"] = 2] = "Multiple";
    })(UseMethod = exports.UseMethod || (exports.UseMethod = {}));
    var TokenStandard;
    (function(TokenStandard2) {
      TokenStandard2[TokenStandard2["NonFungible"] = 0] = "NonFungible";
      TokenStandard2[TokenStandard2["FungibleAsset"] = 1] = "FungibleAsset";
      TokenStandard2[TokenStandard2["Fungible"] = 2] = "Fungible";
      TokenStandard2[TokenStandard2["NonFungibleEdition"] = 3] = "NonFungibleEdition";
    })(TokenStandard = exports.TokenStandard || (exports.TokenStandard = {}));
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee7542 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength2(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare2(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength2(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect2() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      let val = this[offset + --byteLength3];
      let mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let i = byteLength3;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let i = byteLength3 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i = byteLength3 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee7542.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee7542.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage2, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage2.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength3) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
        boundsError(offset, buf.length - (byteLength3 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength3) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength3 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength3);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/errors.js
var require_errors = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERROR_ACCOUNT_NOT_FOUND = exports.ERROR_DEPRECATED_ACCOUNT_DATA = exports.ERROR_INVALID_ACCOUNT_DATA = exports.ERROR_INVALID_OWNER = exports.MetaplexError = exports.ErrorCode = void 0;
    var ErrorCode;
    (function(ErrorCode2) {
      ErrorCode2[ErrorCode2["ERROR_INVALID_OWNER"] = 0] = "ERROR_INVALID_OWNER";
      ErrorCode2[ErrorCode2["ERROR_INVALID_ACCOUNT_DATA"] = 1] = "ERROR_INVALID_ACCOUNT_DATA";
      ErrorCode2[ErrorCode2["ERROR_DEPRECATED_ACCOUNT_DATA"] = 2] = "ERROR_DEPRECATED_ACCOUNT_DATA";
      ErrorCode2[ErrorCode2["ERROR_ACCOUNT_NOT_FOUND"] = 3] = "ERROR_ACCOUNT_NOT_FOUND";
    })(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
    var MetaplexError = class extends Error {
      constructor(errorCode, message) {
        super(message);
        this.errorCode = errorCode;
      }
    };
    exports.MetaplexError = MetaplexError;
    var ERROR_INVALID_OWNER = () => {
      return new MetaplexError(ErrorCode.ERROR_INVALID_OWNER, "Invalid owner");
    };
    exports.ERROR_INVALID_OWNER = ERROR_INVALID_OWNER;
    var ERROR_INVALID_ACCOUNT_DATA = () => {
      return new MetaplexError(ErrorCode.ERROR_INVALID_ACCOUNT_DATA, "Invalid data");
    };
    exports.ERROR_INVALID_ACCOUNT_DATA = ERROR_INVALID_ACCOUNT_DATA;
    var ERROR_DEPRECATED_ACCOUNT_DATA = () => {
      return new MetaplexError(ErrorCode.ERROR_DEPRECATED_ACCOUNT_DATA, "Account data is deprecated");
    };
    exports.ERROR_DEPRECATED_ACCOUNT_DATA = ERROR_DEPRECATED_ACCOUNT_DATA;
    var ERROR_ACCOUNT_NOT_FOUND = (pubkey) => {
      return new MetaplexError(ErrorCode.ERROR_ACCOUNT_NOT_FOUND, `Unable to find account: ${pubkey}`);
    };
    exports.ERROR_ACCOUNT_NOT_FOUND = ERROR_ACCOUNT_NOT_FOUND;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/accounts/Account.js
var require_Account = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/accounts/Account.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Account = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var buffer_1 = require_buffer();
    var errors_1 = require_errors();
    var Account = class {
      constructor(pubkey, info) {
        this.pubkey = new web3_js_1.PublicKey(pubkey);
        this.info = info;
      }
      static from(account) {
        return new this(account.pubkey, account.info);
      }
      static load(connection, pubkey) {
        return __awaiter(this, void 0, void 0, function* () {
          const info = yield Account.getInfo(connection, pubkey);
          return new this(pubkey, info);
        });
      }
      static isCompatible(_data) {
        throw new Error(`method 'isCompatible' is not implemented`);
      }
      static getInfo(connection, pubkey) {
        return __awaiter(this, void 0, void 0, function* () {
          const info = yield connection.getAccountInfo(new web3_js_1.PublicKey(pubkey));
          if (!info) {
            throw (0, errors_1.ERROR_ACCOUNT_NOT_FOUND)(pubkey);
          }
          return Object.assign(Object.assign({}, info), { data: buffer_1.Buffer.from(info === null || info === void 0 ? void 0 : info.data) });
        });
      }
      static getInfos(connection, pubkeys, commitment = "recent") {
        return __awaiter(this, void 0, void 0, function* () {
          const BATCH_SIZE = 99;
          const promises = [];
          for (let i = 0; i < pubkeys.length; i += BATCH_SIZE) {
            promises.push(Account.getMultipleAccounts(connection, pubkeys.slice(i, Math.min(pubkeys.length, i + BATCH_SIZE)), commitment));
          }
          const results = /* @__PURE__ */ new Map();
          (yield Promise.all(promises)).forEach((result) => {
            var _a;
            return [...(_a = result === null || result === void 0 ? void 0 : result.entries()) !== null && _a !== void 0 ? _a : []].forEach(([k, v]) => results.set(k, v));
          });
          return results;
        });
      }
      static getMultipleAccounts(connection, pubkeys, commitment) {
        return __awaiter(this, void 0, void 0, function* () {
          const args = connection._buildArgs([pubkeys.map((k) => k.toString())], commitment, "base64");
          const unsafeRes = yield connection._rpcRequest("getMultipleAccounts", args);
          if (unsafeRes.error) {
            throw new Error("failed to get info about accounts " + unsafeRes.error.message);
          }
          if (!unsafeRes.result.value)
            return;
          const infos = unsafeRes.result.value.filter(Boolean).map((info) => Object.assign(Object.assign({}, info), { data: buffer_1.Buffer.from(info.data[0], "base64") }));
          return infos.reduce((acc, info, index) => {
            acc.set(pubkeys[index], info);
            return acc;
          }, /* @__PURE__ */ new Map());
        });
      }
      assertOwner(pubkey) {
        var _a;
        return (_a = this.info) === null || _a === void 0 ? void 0 : _a.owner.equals(new web3_js_1.PublicKey(pubkey));
      }
      toJSON() {
        var _a, _b, _c, _d, _e;
        return {
          pubkey: this.pubkey.toString(),
          info: {
            executable: !!((_a = this.info) === null || _a === void 0 ? void 0 : _a.executable),
            owner: ((_b = this.info) === null || _b === void 0 ? void 0 : _b.owner) ? new web3_js_1.PublicKey((_c = this.info) === null || _c === void 0 ? void 0 : _c.owner) : null,
            lamports: (_d = this.info) === null || _d === void 0 ? void 0 : _d.lamports,
            data: (_e = this.info) === null || _e === void 0 ? void 0 : _e.data.toJSON()
          },
          data: this.data
        };
      }
      toString() {
        return JSON.stringify(this.toJSON());
      }
    };
    exports.Account = Account;
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/index.browser.esm.js
var index_browser_esm_exports2 = {};
__export(index_browser_esm_exports2, {
  ASSOCIATED_TOKEN_PROGRAM_ID: () => ASSOCIATED_TOKEN_PROGRAM_ID,
  AccountLayout: () => AccountLayout,
  MintLayout: () => MintLayout,
  NATIVE_MINT: () => NATIVE_MINT,
  TOKEN_PROGRAM_ID: () => TOKEN_PROGRAM_ID,
  Token: () => Token,
  u64: () => u64
});
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
function inspect$1(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect$1.styles[styleType];
  if (style) {
    return "\x1B[" + inspect$1.colors[style][0] + "m" + str + "\x1B[" + inspect$1.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect$1 && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError(value);
  }
  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        String(i),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function(prev, cur) {
    if (cur.indexOf("\n") >= 0)
      ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== "undefined") {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = function() {
    return function foo() {
    }.name === "foo";
  }();
}
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (buffer.isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global$1.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
function assert(value, message) {
  if (!value)
    fail(value, true, message, "==", ok);
}
function getName(func) {
  if (!isFunction(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
function AssertionError(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err = new Error();
    if (err.stack) {
      var out = err.stack;
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
function truncate(s, n) {
  if (typeof s === "string") {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames() || !isFunction(something)) {
    return inspect$1(something);
  }
  var rawname = getName(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
function getMessage(self2) {
  return truncate(inspect(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect(self2.expected), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
function ok(value, message) {
  if (!value)
    fail(value, true, message, "==", ok);
}
function equal(actual, expected, message) {
  if (actual != expected)
    fail(actual, expected, message, "==", equal);
}
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, "!=", notEqual);
  }
}
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "deepEqual", deepEqual);
  }
}
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
  }
}
function _deepEqual(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (buffer.isBuffer(actual) && buffer.isBuffer(expected)) {
    return compare(actual, expected) === 0;
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (buffer.isBuffer(actual) !== buffer.isBuffer(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === void 0 || b === null || b === void 0)
    return false;
  if (isPrimitive(a) || isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "notDeepEqual", notDeepEqual);
  }
}
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
  }
}
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, "===", strictEqual);
  }
}
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, "!==", notStrictEqual);
  }
}
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}
function _throws(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
function throws(block, error, message) {
  _throws(true, block, error, message);
}
function doesNotThrow(block, error, message) {
  _throws(false, block, error, message);
}
function ifError(err) {
  if (err)
    throw err;
}
function nameWithProperty(name, lo) {
  if (lo.property) {
    return name + "[" + lo.property + "]";
  }
  return name;
}
function bindConstructorLayout(Class, layout) {
  if ("function" !== typeof Class) {
    throw new TypeError("Class must be constructor");
  }
  if (Class.hasOwnProperty("layout_")) {
    throw new Error("Class is already bound to a layout");
  }
  if (!(layout && layout instanceof Layout)) {
    throw new TypeError("layout must be a Layout");
  }
  if (layout.hasOwnProperty("boundConstructor_")) {
    throw new Error("layout is already bound to a constructor");
  }
  Class.layout_ = layout;
  layout.boundConstructor_ = Class;
  layout.makeDestinationObject = () => new Class();
  Object.defineProperty(Class.prototype, "encode", {
    value: function(b, offset) {
      return layout.encode(this, b, offset);
    },
    writable: true
  });
  Object.defineProperty(Class, "decode", {
    value: function(b, offset) {
      return layout.decode(b, offset);
    },
    writable: true
  });
}
function divmodInt64(src) {
  const hi32 = Math.floor(src / V2E32);
  const lo32 = src - hi32 * V2E32;
  return { hi32, lo32 };
}
function roundedInt64(hi32, lo32) {
  return hi32 * V2E32 + lo32;
}
function fixBitwiseResult(v) {
  if (0 > v) {
    v += 4294967296;
  }
  return v;
}
function sendAndConfirmTransaction2(title, connection, transaction, ...signers) {
  return sendAndConfirmTransaction(connection, transaction, signers, {
    skipPreflight: false
  });
}
function pubkeyToBuffer(publicKey2) {
  return buffer.Buffer.from(publicKey2.toBuffer());
}
function isAccount(accountOrPublicKey) {
  return "publicKey" in accountOrPublicKey;
}
var import_bn, buffer, base64Js, lookup, revLookup, Arr, code, i, len, ieee754, global$1, inherits, inherits$1, hasOwn, objectKeys, pSlice, _functionsHaveNames, regex, Layout$1, Layout, ExternalLayout, GreedyCount, OffsetLayout, UInt, UIntBE, Int, IntBE, V2E32, NearUInt64, NearUInt64BE, NearInt64, NearInt64BE, Float, FloatBE, Double, DoubleBE, Sequence, Structure, UnionDiscriminator, UnionLayoutDiscriminator, Union, VariantLayout, BitStructure, BitField, Boolean2, Blob, CString, UTF8, Constant, u8, u32, struct, blob, publicKey, uint64, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID, FAILED_TO_FIND_ACCOUNT, INVALID_ACCOUNT_OWNER, u64, AuthorityTypeCodes, NATIVE_MINT, MintLayout, AccountLayout, MultisigLayout, Token;
var init_index_browser_esm2 = __esm({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/index.browser.esm.js"() {
    init_defineProperty();
    import_bn = __toESM(require_bn());
    init_index_browser_esm();
    buffer = {};
    base64Js = {};
    base64Js.byteLength = byteLength;
    base64Js.toByteArray = toByteArray;
    base64Js.fromByteArray = fromByteArray;
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    ieee754 = {};
    ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer2[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer2[offset + i - d] |= s * 128;
    };
    (function(exports) {
      const base64 = base64Js;
      const ieee754$1 = ieee754;
      const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      const K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength2(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare2(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer2 = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer2.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer2, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer2,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer2, pos);
          }
          pos += buf.length;
        }
        return buffer2;
      };
      function byteLength2(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength2;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect2() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
        if (buffer2.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer2.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer2.length + byteOffset;
        if (byteOffset >= buffer2.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer2.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      const MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength3 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength3, this.length);
        }
        let val = this[offset + --byteLength3];
        let mul = 1;
        while (byteLength3 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength3] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength3 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        let i = byteLength3;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754$1.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754$1.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754$1.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754$1.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength3 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        let i = byteLength3 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength3 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        let i = byteLength3 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4);
        }
        ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8);
        }
        ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code2 = val.charCodeAt(0);
            if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
              val = code2;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      const errors = {};
      function E(sym, getMessage2, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage2.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength3) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
          boundsError(offset, buf.length - (byteLength3 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength3) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength3 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength3);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      const hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    })(buffer);
    global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits$1 = inherits;
    inspect$1.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect$1.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
    hasOwn = Object.prototype.hasOwnProperty;
    objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj) {
        if (hasOwn.call(obj, key))
          keys.push(key);
      }
      return keys;
    };
    pSlice = Array.prototype.slice;
    regex = /\s*function\s+([^\(\s]*)\s*/;
    assert.AssertionError = AssertionError;
    inherits$1(AssertionError, Error);
    assert.fail = fail;
    assert.ok = ok;
    assert.equal = equal;
    assert.notEqual = notEqual;
    assert.deepEqual = deepEqual;
    assert.deepStrictEqual = deepStrictEqual;
    assert.notDeepEqual = notDeepEqual;
    assert.notDeepStrictEqual = notDeepStrictEqual;
    assert.strictEqual = strictEqual;
    assert.notStrictEqual = notStrictEqual;
    assert.throws = throws;
    assert.doesNotThrow = doesNotThrow;
    assert.ifError = ifError;
    Layout$1 = {};
    Layout = class {
      constructor(span, property) {
        if (!Number.isInteger(span)) {
          throw new TypeError("span must be an integer");
        }
        this.span = span;
        this.property = property;
      }
      makeDestinationObject() {
        return {};
      }
      decode(b, offset) {
        throw new Error("Layout is abstract");
      }
      encode(src, b, offset) {
        throw new Error("Layout is abstract");
      }
      getSpan(b, offset) {
        if (0 > this.span) {
          throw new RangeError("indeterminate span");
        }
        return this.span;
      }
      replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      fromArray(values) {
        return void 0;
      }
    };
    Layout$1.Layout = Layout;
    Layout$1.nameWithProperty = nameWithProperty;
    Layout$1.bindConstructorLayout = bindConstructorLayout;
    ExternalLayout = class extends Layout {
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    };
    GreedyCount = class extends ExternalLayout {
      constructor(elementSpan, property) {
        if (void 0 === elementSpan) {
          elementSpan = 1;
        }
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
          throw new TypeError("elementSpan must be a (positive) integer");
        }
        super(-1, property);
        this.elementSpan = elementSpan;
      }
      isCount() {
        return true;
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const rem = b.length - offset;
        return Math.floor(rem / this.elementSpan);
      }
      encode(src, b, offset) {
        return 0;
      }
    };
    OffsetLayout = class extends ExternalLayout {
      constructor(layout, offset, property) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (void 0 === offset) {
          offset = 0;
        } else if (!Number.isInteger(offset)) {
          throw new TypeError("offset must be integer or undefined");
        }
        super(layout.span, property || layout.property);
        this.layout = layout;
        this.offset = offset;
      }
      isCount() {
        return this.layout instanceof UInt || this.layout instanceof UIntBE;
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return this.layout.decode(b, offset + this.offset);
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return this.layout.encode(src, b, offset + this.offset);
      }
    };
    UInt = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readUIntLE(offset, this.span);
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeUIntLE(src, offset, this.span);
        return this.span;
      }
    };
    UIntBE = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readUIntBE(offset, this.span);
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeUIntBE(src, offset, this.span);
        return this.span;
      }
    };
    Int = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readIntLE(offset, this.span);
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeIntLE(src, offset, this.span);
        return this.span;
      }
    };
    IntBE = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readIntBE(offset, this.span);
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeIntBE(src, offset, this.span);
        return this.span;
      }
    };
    V2E32 = Math.pow(2, 32);
    NearUInt64 = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const lo32 = b.readUInt32LE(offset);
        const hi32 = b.readUInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const split = divmodInt64(src);
        b.writeUInt32LE(split.lo32, offset);
        b.writeUInt32LE(split.hi32, offset + 4);
        return 8;
      }
    };
    NearUInt64BE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const hi32 = b.readUInt32BE(offset);
        const lo32 = b.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const split = divmodInt64(src);
        b.writeUInt32BE(split.hi32, offset);
        b.writeUInt32BE(split.lo32, offset + 4);
        return 8;
      }
    };
    NearInt64 = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const lo32 = b.readUInt32LE(offset);
        const hi32 = b.readInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const split = divmodInt64(src);
        b.writeUInt32LE(split.lo32, offset);
        b.writeInt32LE(split.hi32, offset + 4);
        return 8;
      }
    };
    NearInt64BE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const hi32 = b.readInt32BE(offset);
        const lo32 = b.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const split = divmodInt64(src);
        b.writeInt32BE(split.hi32, offset);
        b.writeUInt32BE(split.lo32, offset + 4);
        return 8;
      }
    };
    Float = class extends Layout {
      constructor(property) {
        super(4, property);
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readFloatLE(offset);
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeFloatLE(src, offset);
        return 4;
      }
    };
    FloatBE = class extends Layout {
      constructor(property) {
        super(4, property);
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readFloatBE(offset);
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeFloatBE(src, offset);
        return 4;
      }
    };
    Double = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readDoubleLE(offset);
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeDoubleLE(src, offset);
        return 8;
      }
    };
    DoubleBE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readDoubleBE(offset);
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeDoubleBE(src, offset);
        return 8;
      }
    };
    Sequence = class extends Layout {
      constructor(elementLayout, count, property) {
        if (!(elementLayout instanceof Layout)) {
          throw new TypeError("elementLayout must be a Layout");
        }
        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
          throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
          span = count * elementLayout.span;
        }
        super(span, property);
        this.elementLayout = elementLayout;
        this.count = count;
      }
      getSpan(b, offset) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset) {
          offset = 0;
        }
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset);
        }
        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          let idx = 0;
          while (idx < count) {
            span += this.elementLayout.getSpan(b, offset + span);
            ++idx;
          }
        }
        return span;
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const rv = [];
        let i = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset);
        }
        while (i < count) {
          rv.push(this.elementLayout.decode(b, offset));
          offset += this.elementLayout.getSpan(b, offset);
          i += 1;
        }
        return rv;
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const elo = this.elementLayout;
        const span = src.reduce((span2, v) => {
          return span2 + elo.encode(v, b, offset + span2);
        }, 0);
        if (this.count instanceof ExternalLayout) {
          this.count.encode(src.length, b, offset);
        }
        return span;
      }
    };
    Structure = class extends Layout {
      constructor(fields, property, decodePrefixes) {
        if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {
          throw new TypeError("fields must be array of Layout instances");
        }
        if ("boolean" === typeof property && void 0 === decodePrefixes) {
          decodePrefixes = property;
          property = void 0;
        }
        for (const fd of fields) {
          if (0 > fd.span && void 0 === fd.property) {
            throw new Error("fields cannot contain unnamed variable-length layout");
          }
        }
        let span = -1;
        try {
          span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
        } catch (e) {
        }
        super(span, property);
        this.fields = fields;
        this.decodePrefixes = !!decodePrefixes;
      }
      getSpan(b, offset) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset) {
          offset = 0;
        }
        let span = 0;
        try {
          span = this.fields.reduce((span2, fd) => {
            const fsp = fd.getSpan(b, offset);
            offset += fsp;
            return span2 + fsp;
          }, 0);
        } catch (e) {
          throw new RangeError("indeterminate span");
        }
        return span;
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b, offset);
          }
          offset += fd.getSpan(b, offset);
          if (this.decodePrefixes && b.length === offset) {
            break;
          }
        }
        return dest;
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const firstOffset = offset;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd of this.fields) {
          let span = fd.span;
          lastWrote = 0 < span ? span : 0;
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              lastWrote = fd.encode(fv, b, offset);
              if (0 > span) {
                span = fd.getSpan(b, offset);
              }
            }
          }
          lastOffset = offset;
          offset += span;
        }
        return lastOffset + lastWrote - firstOffset;
      }
      fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property && 0 < values.length) {
            dest[fd.property] = values.shift();
          }
        }
        return dest;
      }
      layoutFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
      }
      offsetOf(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        let offset = 0;
        for (const fd of this.fields) {
          if (fd.property === property) {
            return offset;
          }
          if (0 > fd.span) {
            offset = -1;
          } else if (0 <= offset) {
            offset += fd.span;
          }
        }
      }
    };
    UnionDiscriminator = class {
      constructor(property) {
        this.property = property;
      }
      decode() {
        throw new Error("UnionDiscriminator is abstract");
      }
      encode() {
        throw new Error("UnionDiscriminator is abstract");
      }
    };
    UnionLayoutDiscriminator = class extends UnionDiscriminator {
      constructor(layout, property) {
        if (!(layout instanceof ExternalLayout && layout.isCount())) {
          throw new TypeError("layout must be an unsigned integer ExternalLayout");
        }
        super(property || layout.property || "variant");
        this.layout = layout;
      }
      decode(b, offset) {
        return this.layout.decode(b, offset);
      }
      encode(src, b, offset) {
        return this.layout.encode(src, b, offset);
      }
    };
    Union = class extends Layout {
      constructor(discr, defaultLayout, property) {
        const upv = discr instanceof UInt || discr instanceof UIntBE;
        if (upv) {
          discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));
        } else if (discr instanceof ExternalLayout && discr.isCount()) {
          discr = new UnionLayoutDiscriminator(discr);
        } else if (!(discr instanceof UnionDiscriminator)) {
          throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        }
        if (void 0 === defaultLayout) {
          defaultLayout = null;
        }
        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
          throw new TypeError("defaultLayout must be null or a Layout");
        }
        if (null !== defaultLayout) {
          if (0 > defaultLayout.span) {
            throw new Error("defaultLayout must have constant span");
          }
          if (void 0 === defaultLayout.property) {
            defaultLayout = defaultLayout.replicate("content");
          }
        }
        let span = -1;
        if (defaultLayout) {
          span = defaultLayout.span;
          if (0 <= span && upv) {
            span += discr.layout.span;
          }
        }
        super(span, property);
        this.discriminator = discr;
        this.usesPrefixDiscriminator = upv;
        this.defaultLayout = defaultLayout;
        this.registry = {};
        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(src) {
          return boundGetSourceVariant(src);
        };
        this.configGetSourceVariant = function(gsv) {
          boundGetSourceVariant = gsv.bind(this);
        };
      }
      getSpan(b, offset) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset) {
          offset = 0;
        }
        const vlo = this.getVariant(b, offset);
        if (!vlo) {
          throw new Error("unable to determine span for unrecognized variant");
        }
        return vlo.getSpan(b, offset);
      }
      defaultGetSourceVariant(src) {
        if (src.hasOwnProperty(this.discriminator.property)) {
          if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
            return void 0;
          }
          const vlo = this.registry[src[this.discriminator.property]];
          if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
            return vlo;
          }
        } else {
          for (const tag in this.registry) {
            const vlo = this.registry[tag];
            if (src.hasOwnProperty(vlo.property)) {
              return vlo;
            }
          }
        }
        throw new Error("unable to infer src variant");
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b, offset);
        let clo = this.registry[discr];
        if (void 0 === clo) {
          let contentOffset = 0;
          clo = this.defaultLayout;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);
        } else {
          dest = clo.decode(b, offset);
        }
        return dest;
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const vlo = this.getSourceVariant(src);
        if (void 0 === vlo) {
          const dlo = this.discriminator;
          const clo = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dlo.encode(src[dlo.property], b, offset);
          return contentOffset + clo.encode(
            src[clo.property],
            b,
            offset + contentOffset
          );
        }
        return vlo.encode(src, b, offset);
      }
      addVariant(variant, layout, property) {
        const rv = new VariantLayout(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      getVariant(vb, offset) {
        let variant = vb;
        if (buffer.Buffer.isBuffer(vb)) {
          if (void 0 === offset) {
            offset = 0;
          }
          variant = this.discriminator.decode(vb, offset);
        }
        return this.registry[variant];
      }
    };
    VariantLayout = class extends Layout {
      constructor(union, variant, layout, property) {
        if (!(union instanceof Union)) {
          throw new TypeError("union must be a Union");
        }
        if (!Number.isInteger(variant) || 0 > variant) {
          throw new TypeError("variant must be a (non-negative) integer");
        }
        if ("string" === typeof layout && void 0 === property) {
          property = layout;
          layout = null;
        }
        if (layout) {
          if (!(layout instanceof Layout)) {
            throw new TypeError("layout must be a Layout");
          }
          if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {
            throw new Error("variant span exceeds span of containing union");
          }
          if ("string" !== typeof property) {
            throw new TypeError("variant must have a String property");
          }
        }
        let span = union.span;
        if (0 > union.span) {
          span = layout ? layout.span : 0;
          if (0 <= span && union.usesPrefixDiscriminator) {
            span += union.discriminator.layout.span;
          }
        }
        super(span, property);
        this.union = union;
        this.variant = variant;
        this.layout = layout || null;
      }
      getSpan(b, offset) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset) {
          offset = 0;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        return contentOffset + this.layout.getSpan(b, offset + contentOffset);
      }
      decode(b, offset) {
        const dest = this.makeDestinationObject();
        if (void 0 === offset) {
          offset = 0;
        }
        if (this !== this.union.getVariant(b, offset)) {
          throw new Error("variant mismatch");
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout) {
          dest[this.property] = this.layout.decode(b, offset + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout && !src.hasOwnProperty(this.property)) {
          throw new TypeError("variant lacks property " + this.property);
        }
        this.union.discriminator.encode(this.variant, b, offset);
        let span = contentOffset;
        if (this.layout) {
          this.layout.encode(src[this.property], b, offset + contentOffset);
          span += this.layout.getSpan(b, offset + contentOffset);
          if (0 <= this.union.span && span > this.union.span) {
            throw new Error("encoded variant overruns containing union");
          }
        }
        return span;
      }
      fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
      }
    };
    BitStructure = class extends Layout {
      constructor(word, msb, property) {
        if (!(word instanceof UInt || word instanceof UIntBE)) {
          throw new TypeError("word must be a UInt or UIntBE layout");
        }
        if ("string" === typeof msb && void 0 === property) {
          property = msb;
          msb = void 0;
        }
        if (4 < word.span) {
          throw new RangeError("word cannot exceed 32 bits");
        }
        super(word.span, property);
        this.word = word;
        this.msb = !!msb;
        this.fields = [];
        let value = 0;
        this._packedSetValue = function(v) {
          value = fixBitwiseResult(v);
          return this;
        };
        this._packedGetValue = function() {
          return value;
        };
      }
      decode(b, offset) {
        const dest = this.makeDestinationObject();
        if (void 0 === offset) {
          offset = 0;
        }
        const value = this.word.decode(b, offset);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(value);
          }
        }
        return dest;
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const value = this.word.decode(b, offset);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              fd.encode(fv);
            }
          }
        }
        return this.word.encode(this._packedGetValue(), b, offset);
      }
      addField(bits, property) {
        const bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
      }
      addBoolean(property) {
        const bf = new Boolean2(this, property);
        this.fields.push(bf);
        return bf;
      }
      fieldFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
      }
    };
    BitField = class {
      constructor(container, bits, property) {
        if (!(container instanceof BitStructure)) {
          throw new TypeError("container must be a BitStructure");
        }
        if (!Number.isInteger(bits) || 0 >= bits) {
          throw new TypeError("bits must be positive integer");
        }
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
        if (bits + usedBits > totalBits) {
          throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        }
        this.container = container;
        this.bits = bits;
        this.valueMask = (1 << bits) - 1;
        if (32 === bits) {
          this.valueMask = 4294967295;
        }
        this.start = usedBits;
        if (this.container.msb) {
          this.start = totalBits - usedBits - bits;
        }
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        this.property = property;
      }
      decode() {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value = wordValue >>> this.start;
        return value;
      }
      encode(value) {
        if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
          throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        }
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      }
    };
    Boolean2 = class extends BitField {
      constructor(container, property) {
        super(container, 1, property);
      }
      decode(b, offset) {
        return !!BitField.prototype.decode.call(this, b, offset);
      }
      encode(value) {
        if ("boolean" === typeof value) {
          value = +value;
        }
        return BitField.prototype.encode.call(this, value);
      }
    };
    Blob = class extends Layout {
      constructor(length, property) {
        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
          throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(length instanceof ExternalLayout)) {
          span = length;
        }
        super(span, property);
        this.length = length;
      }
      getSpan(b, offset) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset);
        }
        return span;
      }
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset);
        }
        return b.slice(offset, offset + span);
      }
      encode(src, b, offset) {
        let span = this.length;
        if (this.length instanceof ExternalLayout) {
          span = src.length;
        }
        if (!(buffer.Buffer.isBuffer(src) && span === src.length)) {
          throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
        }
        if (offset + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        b.write(src.toString("hex"), offset, span, "hex");
        if (this.length instanceof ExternalLayout) {
          this.length.encode(span, b, offset);
        }
        return span;
      }
    };
    CString = class extends Layout {
      constructor(property) {
        super(-1, property);
      }
      getSpan(b, offset) {
        if (!buffer.Buffer.isBuffer(b)) {
          throw new TypeError("b must be a Buffer");
        }
        if (void 0 === offset) {
          offset = 0;
        }
        let idx = offset;
        while (idx < b.length && 0 !== b[idx]) {
          idx += 1;
        }
        return 1 + idx - offset;
      }
      decode(b, offset, dest) {
        if (void 0 === offset) {
          offset = 0;
        }
        let span = this.getSpan(b, offset);
        return b.slice(offset, offset + span - 1).toString("utf-8");
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        if ("string" !== typeof src) {
          src = src.toString();
        }
        const srcb = new buffer.Buffer(src, "utf8");
        const span = srcb.length;
        if (offset + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(b, offset);
        b[offset + span] = 0;
        return span + 1;
      }
    };
    UTF8 = class extends Layout {
      constructor(maxSpan, property) {
        if ("string" === typeof maxSpan && void 0 === property) {
          property = maxSpan;
          maxSpan = void 0;
        }
        if (void 0 === maxSpan) {
          maxSpan = -1;
        } else if (!Number.isInteger(maxSpan)) {
          throw new TypeError("maxSpan must be an integer");
        }
        super(-1, property);
        this.maxSpan = maxSpan;
      }
      getSpan(b, offset) {
        if (!buffer.Buffer.isBuffer(b)) {
          throw new TypeError("b must be a Buffer");
        }
        if (void 0 === offset) {
          offset = 0;
        }
        return b.length - offset;
      }
      decode(b, offset, dest) {
        if (void 0 === offset) {
          offset = 0;
        }
        let span = this.getSpan(b, offset);
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        return b.slice(offset, offset + span).toString("utf-8");
      }
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        if ("string" !== typeof src) {
          src = src.toString();
        }
        const srcb = new buffer.Buffer(src, "utf8");
        const span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        if (offset + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(b, offset);
        return span;
      }
    };
    Constant = class extends Layout {
      constructor(value, property) {
        super(0, property);
        this.value = value;
      }
      decode(b, offset, dest) {
        return this.value;
      }
      encode(src, b, offset) {
        return 0;
      }
    };
    Layout$1.ExternalLayout = ExternalLayout;
    Layout$1.GreedyCount = GreedyCount;
    Layout$1.OffsetLayout = OffsetLayout;
    Layout$1.UInt = UInt;
    Layout$1.UIntBE = UIntBE;
    Layout$1.Int = Int;
    Layout$1.IntBE = IntBE;
    Layout$1.Float = Float;
    Layout$1.FloatBE = FloatBE;
    Layout$1.Double = Double;
    Layout$1.DoubleBE = DoubleBE;
    Layout$1.Sequence = Sequence;
    Layout$1.Structure = Structure;
    Layout$1.UnionDiscriminator = UnionDiscriminator;
    Layout$1.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
    Layout$1.Union = Union;
    Layout$1.VariantLayout = VariantLayout;
    Layout$1.BitStructure = BitStructure;
    Layout$1.BitField = BitField;
    Layout$1.Boolean = Boolean2;
    Layout$1.Blob = Blob;
    Layout$1.CString = CString;
    Layout$1.UTF8 = UTF8;
    Layout$1.Constant = Constant;
    Layout$1.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
    Layout$1.offset = (layout, offset, property) => new OffsetLayout(layout, offset, property);
    u8 = Layout$1.u8 = (property) => new UInt(1, property);
    Layout$1.u16 = (property) => new UInt(2, property);
    Layout$1.u24 = (property) => new UInt(3, property);
    u32 = Layout$1.u32 = (property) => new UInt(4, property);
    Layout$1.u40 = (property) => new UInt(5, property);
    Layout$1.u48 = (property) => new UInt(6, property);
    Layout$1.nu64 = (property) => new NearUInt64(property);
    Layout$1.u16be = (property) => new UIntBE(2, property);
    Layout$1.u24be = (property) => new UIntBE(3, property);
    Layout$1.u32be = (property) => new UIntBE(4, property);
    Layout$1.u40be = (property) => new UIntBE(5, property);
    Layout$1.u48be = (property) => new UIntBE(6, property);
    Layout$1.nu64be = (property) => new NearUInt64BE(property);
    Layout$1.s8 = (property) => new Int(1, property);
    Layout$1.s16 = (property) => new Int(2, property);
    Layout$1.s24 = (property) => new Int(3, property);
    Layout$1.s32 = (property) => new Int(4, property);
    Layout$1.s40 = (property) => new Int(5, property);
    Layout$1.s48 = (property) => new Int(6, property);
    Layout$1.ns64 = (property) => new NearInt64(property);
    Layout$1.s16be = (property) => new IntBE(2, property);
    Layout$1.s24be = (property) => new IntBE(3, property);
    Layout$1.s32be = (property) => new IntBE(4, property);
    Layout$1.s40be = (property) => new IntBE(5, property);
    Layout$1.s48be = (property) => new IntBE(6, property);
    Layout$1.ns64be = (property) => new NearInt64BE(property);
    Layout$1.f32 = (property) => new Float(property);
    Layout$1.f32be = (property) => new FloatBE(property);
    Layout$1.f64 = (property) => new Double(property);
    Layout$1.f64be = (property) => new DoubleBE(property);
    struct = Layout$1.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
    Layout$1.bits = (word, msb, property) => new BitStructure(word, msb, property);
    Layout$1.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
    Layout$1.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
    Layout$1.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
    blob = Layout$1.blob = (length, property) => new Blob(length, property);
    Layout$1.cstr = (property) => new CString(property);
    Layout$1.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
    Layout$1.const = (value, property) => new Constant(value, property);
    publicKey = (property = "publicKey") => {
      return blob(32, property);
    };
    uint64 = (property = "uint64") => {
      return blob(8, property);
    };
    TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
    FAILED_TO_FIND_ACCOUNT = "Failed to find account";
    INVALID_ACCOUNT_OWNER = "Invalid account owner";
    u64 = class extends import_bn.default {
      toBuffer() {
        const a = super.toArray().reverse();
        const b = buffer.Buffer.from(a);
        if (b.length === 8) {
          return b;
        }
        assert(b.length < 8, "u64 too large");
        const zeroPad = buffer.Buffer.alloc(8);
        b.copy(zeroPad);
        return zeroPad;
      }
      static fromBuffer(buffer2) {
        assert(buffer2.length === 8, `Invalid buffer length: ${buffer2.length}`);
        return new u64([...buffer2].reverse().map((i) => `00${i.toString(16)}`.slice(-2)).join(""), 16);
      }
    };
    AuthorityTypeCodes = {
      MintTokens: 0,
      FreezeAccount: 1,
      AccountOwner: 2,
      CloseAccount: 3
    };
    NATIVE_MINT = new PublicKey("So11111111111111111111111111111111111111112");
    MintLayout = struct([u32("mintAuthorityOption"), publicKey("mintAuthority"), uint64("supply"), u8("decimals"), u8("isInitialized"), u32("freezeAuthorityOption"), publicKey("freezeAuthority")]);
    AccountLayout = struct([publicKey("mint"), publicKey("owner"), uint64("amount"), u32("delegateOption"), publicKey("delegate"), u8("state"), u32("isNativeOption"), uint64("isNative"), uint64("delegatedAmount"), u32("closeAuthorityOption"), publicKey("closeAuthority")]);
    MultisigLayout = struct([u8("m"), u8("n"), u8("is_initialized"), publicKey("signer1"), publicKey("signer2"), publicKey("signer3"), publicKey("signer4"), publicKey("signer5"), publicKey("signer6"), publicKey("signer7"), publicKey("signer8"), publicKey("signer9"), publicKey("signer10"), publicKey("signer11")]);
    Token = class {
      constructor(connection, publicKey2, programId, payer) {
        _defineProperty(this, "connection", void 0);
        _defineProperty(this, "publicKey", void 0);
        _defineProperty(this, "programId", void 0);
        _defineProperty(this, "associatedProgramId", void 0);
        _defineProperty(this, "payer", void 0);
        Object.assign(this, {
          connection,
          publicKey: publicKey2,
          programId,
          payer,
          associatedProgramId: ASSOCIATED_TOKEN_PROGRAM_ID
        });
      }
      static async getMinBalanceRentForExemptMint(connection) {
        return await connection.getMinimumBalanceForRentExemption(MintLayout.span);
      }
      static async getMinBalanceRentForExemptAccount(connection) {
        return await connection.getMinimumBalanceForRentExemption(AccountLayout.span);
      }
      static async getMinBalanceRentForExemptMultisig(connection) {
        return await connection.getMinimumBalanceForRentExemption(MultisigLayout.span);
      }
      static async createMint(connection, payer, mintAuthority, freezeAuthority, decimals, programId) {
        const mintAccount = Keypair.generate();
        const token = new Token(connection, mintAccount.publicKey, programId, payer);
        const balanceNeeded = await Token.getMinBalanceRentForExemptMint(connection);
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: mintAccount.publicKey,
          lamports: balanceNeeded,
          space: MintLayout.span,
          programId
        }));
        transaction.add(Token.createInitMintInstruction(programId, mintAccount.publicKey, decimals, mintAuthority, freezeAuthority));
        await sendAndConfirmTransaction2("createAccount and InitializeMint", connection, transaction, payer, mintAccount);
        return token;
      }
      async createAccount(owner) {
        const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(this.connection);
        const newAccount = Keypair.generate();
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: this.payer.publicKey,
          newAccountPubkey: newAccount.publicKey,
          lamports: balanceNeeded,
          space: AccountLayout.span,
          programId: this.programId
        }));
        const mintPublicKey = this.publicKey;
        transaction.add(Token.createInitAccountInstruction(this.programId, mintPublicKey, newAccount.publicKey, owner));
        await sendAndConfirmTransaction2("createAccount and InitializeAccount", this.connection, transaction, this.payer, newAccount);
        return newAccount.publicKey;
      }
      async createAssociatedTokenAccount(owner) {
        const associatedAddress = await Token.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, owner);
        return this.createAssociatedTokenAccountInternal(owner, associatedAddress);
      }
      async createAssociatedTokenAccountInternal(owner, associatedAddress) {
        await sendAndConfirmTransaction2("CreateAssociatedTokenAccount", this.connection, new Transaction().add(Token.createAssociatedTokenAccountInstruction(this.associatedProgramId, this.programId, this.publicKey, associatedAddress, owner, this.payer.publicKey)), this.payer);
        return associatedAddress;
      }
      async getOrCreateAssociatedAccountInfo(owner) {
        const associatedAddress = await Token.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, owner);
        try {
          return await this.getAccountInfo(associatedAddress);
        } catch (err) {
          if (err.message === FAILED_TO_FIND_ACCOUNT || err.message === INVALID_ACCOUNT_OWNER) {
            try {
              await this.createAssociatedTokenAccountInternal(owner, associatedAddress);
            } catch (err2) {
            }
            return await this.getAccountInfo(associatedAddress);
          } else {
            throw err;
          }
        }
      }
      static async createWrappedNativeAccount(connection, programId, owner, payer, amount) {
        const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(connection);
        const newAccount = Keypair.generate();
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: newAccount.publicKey,
          lamports: balanceNeeded,
          space: AccountLayout.span,
          programId
        }));
        transaction.add(SystemProgram.transfer({
          fromPubkey: payer.publicKey,
          toPubkey: newAccount.publicKey,
          lamports: amount
        }));
        transaction.add(Token.createInitAccountInstruction(programId, NATIVE_MINT, newAccount.publicKey, owner));
        await sendAndConfirmTransaction2("createAccount, transfer, and initializeAccount", connection, transaction, payer, newAccount);
        return newAccount.publicKey;
      }
      async createMultisig(m, signers) {
        const multisigAccount = Keypair.generate();
        const balanceNeeded = await Token.getMinBalanceRentForExemptMultisig(this.connection);
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: this.payer.publicKey,
          newAccountPubkey: multisigAccount.publicKey,
          lamports: balanceNeeded,
          space: MultisigLayout.span,
          programId: this.programId
        }));
        let keys = [{
          pubkey: multisigAccount.publicKey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }];
        signers.forEach((signer) => keys.push({
          pubkey: signer,
          isSigner: false,
          isWritable: false
        }));
        const dataLayout = struct([u8("instruction"), u8("m")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 2,
          m
        }, data);
        transaction.add({
          keys,
          programId: this.programId,
          data
        });
        await sendAndConfirmTransaction2("createAccount and InitializeMultisig", this.connection, transaction, this.payer, multisigAccount);
        return multisigAccount.publicKey;
      }
      async getMintInfo() {
        const info = await this.connection.getAccountInfo(this.publicKey);
        if (info === null) {
          throw new Error("Failed to find mint account");
        }
        if (!info.owner.equals(this.programId)) {
          throw new Error(`Invalid mint owner: ${JSON.stringify(info.owner)}`);
        }
        if (info.data.length != MintLayout.span) {
          throw new Error(`Invalid mint size`);
        }
        const data = buffer.Buffer.from(info.data);
        const mintInfo = MintLayout.decode(data);
        if (mintInfo.mintAuthorityOption === 0) {
          mintInfo.mintAuthority = null;
        } else {
          mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);
        }
        mintInfo.supply = u64.fromBuffer(mintInfo.supply);
        mintInfo.isInitialized = mintInfo.isInitialized != 0;
        if (mintInfo.freezeAuthorityOption === 0) {
          mintInfo.freezeAuthority = null;
        } else {
          mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);
        }
        return mintInfo;
      }
      async getAccountInfo(account, commitment) {
        const info = await this.connection.getAccountInfo(account, commitment);
        if (info === null) {
          throw new Error(FAILED_TO_FIND_ACCOUNT);
        }
        if (!info.owner.equals(this.programId)) {
          throw new Error(INVALID_ACCOUNT_OWNER);
        }
        if (info.data.length != AccountLayout.span) {
          throw new Error(`Invalid account size`);
        }
        const data = buffer.Buffer.from(info.data);
        const accountInfo = AccountLayout.decode(data);
        accountInfo.address = account;
        accountInfo.mint = new PublicKey(accountInfo.mint);
        accountInfo.owner = new PublicKey(accountInfo.owner);
        accountInfo.amount = u64.fromBuffer(accountInfo.amount);
        if (accountInfo.delegateOption === 0) {
          accountInfo.delegate = null;
          accountInfo.delegatedAmount = new u64();
        } else {
          accountInfo.delegate = new PublicKey(accountInfo.delegate);
          accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);
        }
        accountInfo.isInitialized = accountInfo.state !== 0;
        accountInfo.isFrozen = accountInfo.state === 2;
        if (accountInfo.isNativeOption === 1) {
          accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);
          accountInfo.isNative = true;
        } else {
          accountInfo.rentExemptReserve = null;
          accountInfo.isNative = false;
        }
        if (accountInfo.closeAuthorityOption === 0) {
          accountInfo.closeAuthority = null;
        } else {
          accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);
        }
        if (!accountInfo.mint.equals(this.publicKey)) {
          throw new Error(`Invalid account mint: ${JSON.stringify(accountInfo.mint)} !== ${JSON.stringify(this.publicKey)}`);
        }
        return accountInfo;
      }
      async getMultisigInfo(multisig) {
        const info = await this.connection.getAccountInfo(multisig);
        if (info === null) {
          throw new Error("Failed to find multisig");
        }
        if (!info.owner.equals(this.programId)) {
          throw new Error(`Invalid multisig owner`);
        }
        if (info.data.length != MultisigLayout.span) {
          throw new Error(`Invalid multisig size`);
        }
        const data = buffer.Buffer.from(info.data);
        const multisigInfo = MultisigLayout.decode(data);
        multisigInfo.signer1 = new PublicKey(multisigInfo.signer1);
        multisigInfo.signer2 = new PublicKey(multisigInfo.signer2);
        multisigInfo.signer3 = new PublicKey(multisigInfo.signer3);
        multisigInfo.signer4 = new PublicKey(multisigInfo.signer4);
        multisigInfo.signer5 = new PublicKey(multisigInfo.signer5);
        multisigInfo.signer6 = new PublicKey(multisigInfo.signer6);
        multisigInfo.signer7 = new PublicKey(multisigInfo.signer7);
        multisigInfo.signer8 = new PublicKey(multisigInfo.signer8);
        multisigInfo.signer9 = new PublicKey(multisigInfo.signer9);
        multisigInfo.signer10 = new PublicKey(multisigInfo.signer10);
        multisigInfo.signer11 = new PublicKey(multisigInfo.signer11);
        return multisigInfo;
      }
      async transfer(source, destination, owner, multiSigners, amount) {
        let ownerPublicKey;
        let signers;
        if (isAccount(owner)) {
          ownerPublicKey = owner.publicKey;
          signers = [owner];
        } else {
          ownerPublicKey = owner;
          signers = multiSigners;
        }
        return await sendAndConfirmTransaction2("Transfer", this.connection, new Transaction().add(Token.createTransferInstruction(this.programId, source, destination, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);
      }
      async approve(account, delegate, owner, multiSigners, amount) {
        let ownerPublicKey;
        let signers;
        if (isAccount(owner)) {
          ownerPublicKey = owner.publicKey;
          signers = [owner];
        } else {
          ownerPublicKey = owner;
          signers = multiSigners;
        }
        await sendAndConfirmTransaction2("Approve", this.connection, new Transaction().add(Token.createApproveInstruction(this.programId, account, delegate, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);
      }
      async revoke(account, owner, multiSigners) {
        let ownerPublicKey;
        let signers;
        if (isAccount(owner)) {
          ownerPublicKey = owner.publicKey;
          signers = [owner];
        } else {
          ownerPublicKey = owner;
          signers = multiSigners;
        }
        await sendAndConfirmTransaction2("Revoke", this.connection, new Transaction().add(Token.createRevokeInstruction(this.programId, account, ownerPublicKey, multiSigners)), this.payer, ...signers);
      }
      async setAuthority(account, newAuthority, authorityType, currentAuthority, multiSigners) {
        let currentAuthorityPublicKey;
        let signers;
        if (isAccount(currentAuthority)) {
          currentAuthorityPublicKey = currentAuthority.publicKey;
          signers = [currentAuthority];
        } else {
          currentAuthorityPublicKey = currentAuthority;
          signers = multiSigners;
        }
        await sendAndConfirmTransaction2("SetAuthority", this.connection, new Transaction().add(Token.createSetAuthorityInstruction(this.programId, account, newAuthority, authorityType, currentAuthorityPublicKey, multiSigners)), this.payer, ...signers);
      }
      async mintTo(dest, authority, multiSigners, amount) {
        let ownerPublicKey;
        let signers;
        if (isAccount(authority)) {
          ownerPublicKey = authority.publicKey;
          signers = [authority];
        } else {
          ownerPublicKey = authority;
          signers = multiSigners;
        }
        await sendAndConfirmTransaction2("MintTo", this.connection, new Transaction().add(Token.createMintToInstruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);
      }
      async burn(account, owner, multiSigners, amount) {
        let ownerPublicKey;
        let signers;
        if (isAccount(owner)) {
          ownerPublicKey = owner.publicKey;
          signers = [owner];
        } else {
          ownerPublicKey = owner;
          signers = multiSigners;
        }
        await sendAndConfirmTransaction2("Burn", this.connection, new Transaction().add(Token.createBurnInstruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);
      }
      async closeAccount(account, dest, authority, multiSigners) {
        let authorityPublicKey;
        let signers;
        if (isAccount(authority)) {
          authorityPublicKey = authority.publicKey;
          signers = [authority];
        } else {
          authorityPublicKey = authority;
          signers = multiSigners;
        }
        await sendAndConfirmTransaction2("CloseAccount", this.connection, new Transaction().add(Token.createCloseAccountInstruction(this.programId, account, dest, authorityPublicKey, multiSigners)), this.payer, ...signers);
      }
      async freezeAccount(account, authority, multiSigners) {
        let authorityPublicKey;
        let signers;
        if (isAccount(authority)) {
          authorityPublicKey = authority.publicKey;
          signers = [authority];
        } else {
          authorityPublicKey = authority;
          signers = multiSigners;
        }
        await sendAndConfirmTransaction2("FreezeAccount", this.connection, new Transaction().add(Token.createFreezeAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer, ...signers);
      }
      async thawAccount(account, authority, multiSigners) {
        let authorityPublicKey;
        let signers;
        if (isAccount(authority)) {
          authorityPublicKey = authority.publicKey;
          signers = [authority];
        } else {
          authorityPublicKey = authority;
          signers = multiSigners;
        }
        await sendAndConfirmTransaction2("ThawAccount", this.connection, new Transaction().add(Token.createThawAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer, ...signers);
      }
      async transferChecked(source, destination, owner, multiSigners, amount, decimals) {
        let ownerPublicKey;
        let signers;
        if (isAccount(owner)) {
          ownerPublicKey = owner.publicKey;
          signers = [owner];
        } else {
          ownerPublicKey = owner;
          signers = multiSigners;
        }
        return await sendAndConfirmTransaction2("TransferChecked", this.connection, new Transaction().add(Token.createTransferCheckedInstruction(this.programId, source, this.publicKey, destination, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);
      }
      async approveChecked(account, delegate, owner, multiSigners, amount, decimals) {
        let ownerPublicKey;
        let signers;
        if (isAccount(owner)) {
          ownerPublicKey = owner.publicKey;
          signers = [owner];
        } else {
          ownerPublicKey = owner;
          signers = multiSigners;
        }
        await sendAndConfirmTransaction2("ApproveChecked", this.connection, new Transaction().add(Token.createApproveCheckedInstruction(this.programId, account, this.publicKey, delegate, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);
      }
      async mintToChecked(dest, authority, multiSigners, amount, decimals) {
        let ownerPublicKey;
        let signers;
        if (isAccount(authority)) {
          ownerPublicKey = authority.publicKey;
          signers = [authority];
        } else {
          ownerPublicKey = authority;
          signers = multiSigners;
        }
        await sendAndConfirmTransaction2("MintToChecked", this.connection, new Transaction().add(Token.createMintToCheckedInstruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);
      }
      async burnChecked(account, owner, multiSigners, amount, decimals) {
        let ownerPublicKey;
        let signers;
        if (isAccount(owner)) {
          ownerPublicKey = owner.publicKey;
          signers = [owner];
        } else {
          ownerPublicKey = owner;
          signers = multiSigners;
        }
        await sendAndConfirmTransaction2("BurnChecked", this.connection, new Transaction().add(Token.createBurnCheckedInstruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);
      }
      async syncNative(nativeAccount) {
        await sendAndConfirmTransaction2("SyncNative", this.connection, new Transaction().add(Token.createSyncNativeInstruction(this.programId, nativeAccount)), this.payer);
      }
      static createInitMintInstruction(programId, mint, decimals, mintAuthority, freezeAuthority) {
        let keys = [{
          pubkey: mint,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }];
        const commandDataLayout = struct([u8("instruction"), u8("decimals"), publicKey("mintAuthority"), u8("option"), publicKey("freezeAuthority")]);
        let data = buffer.Buffer.alloc(1024);
        {
          const encodeLength = commandDataLayout.encode({
            instruction: 0,
            decimals,
            mintAuthority: pubkeyToBuffer(mintAuthority),
            option: freezeAuthority === null ? 0 : 1,
            freezeAuthority: pubkeyToBuffer(freezeAuthority || new PublicKey(0))
          }, data);
          data = data.slice(0, encodeLength);
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createInitAccountInstruction(programId, mint, account, owner) {
        const keys = [{
          pubkey: account,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: mint,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: owner,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }];
        const dataLayout = struct([u8("instruction")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 1
        }, data);
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createTransferInstruction(programId, source, destination, owner, multiSigners, amount) {
        const dataLayout = struct([u8("instruction"), uint64("amount")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 3,
          amount: new u64(amount).toBuffer()
        }, data);
        let keys = [{
          pubkey: source,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: destination,
          isSigner: false,
          isWritable: true
        }];
        if (multiSigners.length === 0) {
          keys.push({
            pubkey: owner,
            isSigner: true,
            isWritable: false
          });
        } else {
          keys.push({
            pubkey: owner,
            isSigner: false,
            isWritable: false
          });
          multiSigners.forEach((signer) => keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
          }));
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createApproveInstruction(programId, account, delegate, owner, multiSigners, amount) {
        const dataLayout = struct([u8("instruction"), uint64("amount")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 4,
          amount: new u64(amount).toBuffer()
        }, data);
        let keys = [{
          pubkey: account,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: delegate,
          isSigner: false,
          isWritable: false
        }];
        if (multiSigners.length === 0) {
          keys.push({
            pubkey: owner,
            isSigner: true,
            isWritable: false
          });
        } else {
          keys.push({
            pubkey: owner,
            isSigner: false,
            isWritable: false
          });
          multiSigners.forEach((signer) => keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
          }));
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createRevokeInstruction(programId, account, owner, multiSigners) {
        const dataLayout = struct([u8("instruction")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 5
        }, data);
        let keys = [{
          pubkey: account,
          isSigner: false,
          isWritable: true
        }];
        if (multiSigners.length === 0) {
          keys.push({
            pubkey: owner,
            isSigner: true,
            isWritable: false
          });
        } else {
          keys.push({
            pubkey: owner,
            isSigner: false,
            isWritable: false
          });
          multiSigners.forEach((signer) => keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
          }));
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createSetAuthorityInstruction(programId, account, newAuthority, authorityType, currentAuthority, multiSigners) {
        const commandDataLayout = struct([u8("instruction"), u8("authorityType"), u8("option"), publicKey("newAuthority")]);
        let data = buffer.Buffer.alloc(1024);
        {
          const encodeLength = commandDataLayout.encode({
            instruction: 6,
            authorityType: AuthorityTypeCodes[authorityType],
            option: newAuthority === null ? 0 : 1,
            newAuthority: pubkeyToBuffer(newAuthority || new PublicKey(0))
          }, data);
          data = data.slice(0, encodeLength);
        }
        let keys = [{
          pubkey: account,
          isSigner: false,
          isWritable: true
        }];
        if (multiSigners.length === 0) {
          keys.push({
            pubkey: currentAuthority,
            isSigner: true,
            isWritable: false
          });
        } else {
          keys.push({
            pubkey: currentAuthority,
            isSigner: false,
            isWritable: false
          });
          multiSigners.forEach((signer) => keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
          }));
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createMintToInstruction(programId, mint, dest, authority, multiSigners, amount) {
        const dataLayout = struct([u8("instruction"), uint64("amount")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 7,
          amount: new u64(amount).toBuffer()
        }, data);
        let keys = [{
          pubkey: mint,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: dest,
          isSigner: false,
          isWritable: true
        }];
        if (multiSigners.length === 0) {
          keys.push({
            pubkey: authority,
            isSigner: true,
            isWritable: false
          });
        } else {
          keys.push({
            pubkey: authority,
            isSigner: false,
            isWritable: false
          });
          multiSigners.forEach((signer) => keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
          }));
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createBurnInstruction(programId, mint, account, owner, multiSigners, amount) {
        const dataLayout = struct([u8("instruction"), uint64("amount")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 8,
          amount: new u64(amount).toBuffer()
        }, data);
        let keys = [{
          pubkey: account,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: mint,
          isSigner: false,
          isWritable: true
        }];
        if (multiSigners.length === 0) {
          keys.push({
            pubkey: owner,
            isSigner: true,
            isWritable: false
          });
        } else {
          keys.push({
            pubkey: owner,
            isSigner: false,
            isWritable: false
          });
          multiSigners.forEach((signer) => keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
          }));
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createCloseAccountInstruction(programId, account, dest, owner, multiSigners) {
        const dataLayout = struct([u8("instruction")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 9
        }, data);
        let keys = [{
          pubkey: account,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: dest,
          isSigner: false,
          isWritable: true
        }];
        if (multiSigners.length === 0) {
          keys.push({
            pubkey: owner,
            isSigner: true,
            isWritable: false
          });
        } else {
          keys.push({
            pubkey: owner,
            isSigner: false,
            isWritable: false
          });
          multiSigners.forEach((signer) => keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
          }));
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createFreezeAccountInstruction(programId, account, mint, authority, multiSigners) {
        const dataLayout = struct([u8("instruction")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 10
        }, data);
        let keys = [{
          pubkey: account,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: mint,
          isSigner: false,
          isWritable: false
        }];
        if (multiSigners.length === 0) {
          keys.push({
            pubkey: authority,
            isSigner: true,
            isWritable: false
          });
        } else {
          keys.push({
            pubkey: authority,
            isSigner: false,
            isWritable: false
          });
          multiSigners.forEach((signer) => keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
          }));
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createThawAccountInstruction(programId, account, mint, authority, multiSigners) {
        const dataLayout = struct([u8("instruction")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 11
        }, data);
        let keys = [{
          pubkey: account,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: mint,
          isSigner: false,
          isWritable: false
        }];
        if (multiSigners.length === 0) {
          keys.push({
            pubkey: authority,
            isSigner: true,
            isWritable: false
          });
        } else {
          keys.push({
            pubkey: authority,
            isSigner: false,
            isWritable: false
          });
          multiSigners.forEach((signer) => keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
          }));
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createTransferCheckedInstruction(programId, source, mint, destination, owner, multiSigners, amount, decimals) {
        const dataLayout = struct([u8("instruction"), uint64("amount"), u8("decimals")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 12,
          amount: new u64(amount).toBuffer(),
          decimals
        }, data);
        let keys = [{
          pubkey: source,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: mint,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: destination,
          isSigner: false,
          isWritable: true
        }];
        if (multiSigners.length === 0) {
          keys.push({
            pubkey: owner,
            isSigner: true,
            isWritable: false
          });
        } else {
          keys.push({
            pubkey: owner,
            isSigner: false,
            isWritable: false
          });
          multiSigners.forEach((signer) => keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
          }));
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createApproveCheckedInstruction(programId, account, mint, delegate, owner, multiSigners, amount, decimals) {
        const dataLayout = struct([u8("instruction"), uint64("amount"), u8("decimals")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 13,
          amount: new u64(amount).toBuffer(),
          decimals
        }, data);
        let keys = [{
          pubkey: account,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: mint,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: delegate,
          isSigner: false,
          isWritable: false
        }];
        if (multiSigners.length === 0) {
          keys.push({
            pubkey: owner,
            isSigner: true,
            isWritable: false
          });
        } else {
          keys.push({
            pubkey: owner,
            isSigner: false,
            isWritable: false
          });
          multiSigners.forEach((signer) => keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
          }));
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createMintToCheckedInstruction(programId, mint, dest, authority, multiSigners, amount, decimals) {
        const dataLayout = struct([u8("instruction"), uint64("amount"), u8("decimals")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 14,
          amount: new u64(amount).toBuffer(),
          decimals
        }, data);
        let keys = [{
          pubkey: mint,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: dest,
          isSigner: false,
          isWritable: true
        }];
        if (multiSigners.length === 0) {
          keys.push({
            pubkey: authority,
            isSigner: true,
            isWritable: false
          });
        } else {
          keys.push({
            pubkey: authority,
            isSigner: false,
            isWritable: false
          });
          multiSigners.forEach((signer) => keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
          }));
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createBurnCheckedInstruction(programId, mint, account, owner, multiSigners, amount, decimals) {
        const dataLayout = struct([u8("instruction"), uint64("amount"), u8("decimals")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 15,
          amount: new u64(amount).toBuffer(),
          decimals
        }, data);
        let keys = [{
          pubkey: account,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: mint,
          isSigner: false,
          isWritable: true
        }];
        if (multiSigners.length === 0) {
          keys.push({
            pubkey: owner,
            isSigner: true,
            isWritable: false
          });
        } else {
          keys.push({
            pubkey: owner,
            isSigner: false,
            isWritable: false
          });
          multiSigners.forEach((signer) => keys.push({
            pubkey: signer.publicKey,
            isSigner: true,
            isWritable: false
          }));
        }
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static createSyncNativeInstruction(programId, nativeAccount) {
        const dataLayout = struct([u8("instruction")]);
        const data = buffer.Buffer.alloc(dataLayout.span);
        dataLayout.encode({
          instruction: 17
        }, data);
        let keys = [{
          pubkey: nativeAccount,
          isSigner: false,
          isWritable: true
        }];
        return new TransactionInstruction({
          keys,
          programId,
          data
        });
      }
      static async getAssociatedTokenAddress(associatedProgramId, programId, mint, owner, allowOwnerOffCurve = false) {
        if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) {
          throw new Error(`Owner cannot sign: ${owner.toString()}`);
        }
        return (await PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedProgramId))[0];
      }
      static createAssociatedTokenAccountInstruction(associatedProgramId, programId, mint, associatedAccount, owner, payer) {
        const data = buffer.Buffer.alloc(0);
        let keys = [{
          pubkey: payer,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: associatedAccount,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: owner,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: mint,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SystemProgram.programId,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: programId,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }];
        return new TransactionInstruction({
          keys,
          programId: associatedProgramId,
          data
        });
      }
    };
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/accounts/TokenAccount.js
var require_TokenAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/accounts/TokenAccount.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserialize = exports.TokenAccount = void 0;
    var errors_1 = require_errors();
    var Account_1 = require_Account();
    var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var TokenAccount = class extends Account_1.Account {
      constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(spl_token_1.TOKEN_PROGRAM_ID)) {
          throw (0, errors_1.ERROR_INVALID_OWNER)();
        }
        if (!TokenAccount.isCompatible(this.info.data)) {
          throw (0, errors_1.ERROR_INVALID_ACCOUNT_DATA)();
        }
        this.data = (0, exports.deserialize)(this.info.data);
      }
      static isCompatible(data) {
        return data.length === spl_token_1.AccountLayout.span;
      }
      static getTokenAccountsByOwner(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
          return (yield connection.getTokenAccountsByOwner(new web3_js_1.PublicKey(owner), {
            programId: spl_token_1.TOKEN_PROGRAM_ID
          })).value.map(({ pubkey, account }) => new TokenAccount(pubkey, account));
        });
      }
    };
    exports.TokenAccount = TokenAccount;
    var deserialize = (data) => {
      const accountInfo = spl_token_1.AccountLayout.decode(data);
      accountInfo.mint = new web3_js_1.PublicKey(accountInfo.mint);
      accountInfo.owner = new web3_js_1.PublicKey(accountInfo.owner);
      accountInfo.amount = spl_token_1.u64.fromBuffer(accountInfo.amount);
      if (accountInfo.delegateOption === 0) {
        accountInfo.delegate = null;
        accountInfo.delegatedAmount = new spl_token_1.u64(0);
      } else {
        accountInfo.delegate = new web3_js_1.PublicKey(accountInfo.delegate);
        accountInfo.delegatedAmount = spl_token_1.u64.fromBuffer(accountInfo.delegatedAmount);
      }
      accountInfo.isInitialized = accountInfo.state !== 0;
      accountInfo.isFrozen = accountInfo.state === 2;
      if (accountInfo.isNativeOption === 1) {
        accountInfo.rentExemptReserve = spl_token_1.u64.fromBuffer(accountInfo.isNative);
        accountInfo.isNative = true;
      } else {
        accountInfo.rentExemptReserve = null;
        accountInfo.isNative = false;
      }
      if (accountInfo.closeAuthorityOption === 0) {
        accountInfo.closeAuthority = null;
      } else {
        accountInfo.closeAuthority = new web3_js_1.PublicKey(accountInfo.closeAuthority);
      }
      return accountInfo;
    };
    exports.deserialize = deserialize;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/accounts/index.js
var require_accounts = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/accounts/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Account(), exports);
    __exportStar(require_TokenAccount(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/config.js
var require_config = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.config = void 0;
    exports.config = {
      arweaveWallet: "HvwC9QSAzvGXhhVrgPmauVwFWcYZhne3hVot9EbHuFTm",
      programs: {
        auction: "auctxRXPeJoc4817jDhf4HbjnhEcr1cCXenosMhK5R8",
        metadata: "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s",
        metaplex: "p1exdMJcjVao65QdewkaZRUnU6VPSXhus9n2GzWfh98",
        vault: "vau1zxA2LbssAUEF7Gpw91zMM1LvXrvpzJtmZ58rPsn",
        packs: "BNRmGgciUJuyznkYHnmitA9an1BcDDiU9JmjEQwvBYVR",
        memo: "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr",
        token: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
      },
      maxCreatorLimit: 5
    };
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/Program.js
var require_Program = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/Program.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Program = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var accounts_1 = require_accounts();
    var buffer_1 = require_buffer();
    var Program = class {
      static findProgramAddress(seeds) {
        return __awaiter(this, void 0, void 0, function* () {
          return (yield web3_js_1.PublicKey.findProgramAddress(seeds, this.PUBKEY))[0];
        });
      }
      static getProgramAccounts(connection, configOrCommitment) {
        return __awaiter(this, void 0, void 0, function* () {
          const extra = {};
          let commitment;
          if (configOrCommitment) {
            if (typeof configOrCommitment === "string") {
              commitment = configOrCommitment;
            } else {
              commitment = configOrCommitment.commitment;
              if (configOrCommitment.dataSlice) {
                extra.dataSlice = configOrCommitment.dataSlice;
              }
              if (configOrCommitment.filters) {
                extra.filters = configOrCommitment.filters;
              }
            }
          }
          const args = connection._buildArgs([this.PUBKEY.toBase58()], commitment, "base64", extra);
          const unsafeRes = yield connection._rpcRequest("getProgramAccounts", args);
          return unsafeRes.result.map(({ account: { data, executable, lamports, owner }, pubkey }) => ({
            account: {
              data: buffer_1.Buffer.from(data[0], "base64"),
              executable,
              lamports,
              owner: new web3_js_1.PublicKey(owner)
            },
            pubkey: new web3_js_1.PublicKey(pubkey)
          })).map(({ pubkey, account }) => new accounts_1.Account(pubkey, account));
        });
      }
    };
    exports.Program = Program;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/Transaction.js
var require_Transaction = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/Transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transaction = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var Transaction2 = class extends web3_js_1.Transaction {
      constructor(options) {
        super(options);
      }
      static fromCombined(transactions, options = {}) {
        const combinedTransaction = new Transaction2(options);
        transactions.forEach((transaction) => transaction.instructions.forEach((instruction) => {
          combinedTransaction.add(instruction);
        }));
        return combinedTransaction;
      }
    };
    exports.Transaction = Transaction2;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/types.js
var require_types = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/utils/borsh.js
var require_borsh = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/utils/borsh.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialize = exports.deserializeUnchecked = exports.deserialize = exports.struct = exports.Data = exports.extendBorsh = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var borsh_1 = require_lib();
    Object.defineProperty(exports, "deserializeUnchecked", { enumerable: true, get: function() {
      return borsh_1.deserializeUnchecked;
    } });
    Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
      return borsh_1.serialize;
    } });
    Object.defineProperty(exports, "deserialize", { enumerable: true, get: function() {
      return borsh_1.deserialize;
    } });
    var bs58_1 = __importDefault(require_bs58());
    var extendBorsh = () => {
      borsh_1.BinaryReader.prototype.readPubkey = function() {
        const array = this.readFixedArray(32);
        return new web3_js_1.PublicKey(array);
      };
      borsh_1.BinaryWriter.prototype.writePubkey = function(value) {
        this.writeFixedArray(value.toBuffer());
      };
      borsh_1.BinaryReader.prototype.readPubkeyAsString = function() {
        const array = this.readFixedArray(32);
        return bs58_1.default.encode(array);
      };
      borsh_1.BinaryWriter.prototype.writePubkeyAsString = function(value) {
        this.writeFixedArray(bs58_1.default.decode(value));
      };
    };
    exports.extendBorsh = extendBorsh;
    (0, exports.extendBorsh)();
    var Data = class {
      constructor(args = {}) {
        Object.assign(this, args);
      }
      static struct(fields) {
        return (0, exports.struct)(this, fields);
      }
      static serialize(args = {}) {
        return Buffer.from((0, borsh_1.serialize)(this.SCHEMA, new this(args)));
      }
      static deserialize(data) {
        return (0, borsh_1.deserializeUnchecked)(this.SCHEMA, this, data);
      }
    };
    exports.Data = Data;
    var struct2 = (type, fields) => {
      return /* @__PURE__ */ new Map([[type, { kind: "struct", fields }]]);
    };
    exports.struct = struct2;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/utils/tupleNumeric.js
var require_tupleNumeric = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/utils/tupleNumeric.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBNFromData = exports.TupleNumericType = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var TupleNumericType;
    (function(TupleNumericType2) {
      TupleNumericType2[TupleNumericType2["U8"] = 1] = "U8";
      TupleNumericType2[TupleNumericType2["U16"] = 2] = "U16";
      TupleNumericType2[TupleNumericType2["U32"] = 4] = "U32";
      TupleNumericType2[TupleNumericType2["U64"] = 8] = "U64";
    })(TupleNumericType = exports.TupleNumericType || (exports.TupleNumericType = {}));
    var getBNFromData = (data, offset, dataType) => {
      switch (dataType) {
        case TupleNumericType.U8:
          return new bn_js_1.default(data[offset], "le");
        case TupleNumericType.U16:
          return new bn_js_1.default(data.slice(offset, offset + 2), "le");
        case TupleNumericType.U32:
          return new bn_js_1.default(data.slice(offset, offset + 4), "le");
        case TupleNumericType.U64:
          return new bn_js_1.default(data.slice(offset, offset + 8), "le");
      }
    };
    exports.getBNFromData = getBNFromData;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/utils/index.js
var require_utils = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/utils/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Borsh = void 0;
    exports.Borsh = __importStar(require_borsh());
    __exportStar(require_tupleNumeric(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/mpl-core.js
var require_mpl_core = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/mpl-core/dist/src/mpl-core.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_accounts(), exports);
    __exportStar(require_config(), exports);
    __exportStar(require_errors(), exports);
    __exportStar(require_Program(), exports);
    __exportStar(require_Transaction(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_utils(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/MetadataProgram.js
var require_MetadataProgram = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/MetadataProgram.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetadataProgram = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var mpl_core_1 = require_mpl_core();
    var MetadataProgram = class extends mpl_core_1.Program {
      static findEditionAccount(mint, editionNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          return web3_js_1.PublicKey.findProgramAddress([
            Buffer.from(MetadataProgram.PREFIX, "utf8"),
            MetadataProgram.PUBKEY.toBuffer(),
            mint.toBuffer(),
            Buffer.from(MetadataProgram.EDITION, "utf8"),
            Buffer.from(editionNumber, "utf8")
          ], MetadataProgram.PUBKEY);
        });
      }
      static findMasterEditionAccount(mint) {
        return __awaiter(this, void 0, void 0, function* () {
          return web3_js_1.PublicKey.findProgramAddress([
            Buffer.from(MetadataProgram.PREFIX, "utf8"),
            MetadataProgram.PUBKEY.toBuffer(),
            mint.toBuffer(),
            Buffer.from(MetadataProgram.EDITION, "utf8")
          ], MetadataProgram.PUBKEY);
        });
      }
      static findMetadataAccount(mint) {
        return __awaiter(this, void 0, void 0, function* () {
          return web3_js_1.PublicKey.findProgramAddress([
            Buffer.from(MetadataProgram.PREFIX, "utf8"),
            MetadataProgram.PUBKEY.toBuffer(),
            mint.toBuffer()
          ], MetadataProgram.PUBKEY);
        });
      }
      static findUseAuthorityAccount(mint, authority) {
        return __awaiter(this, void 0, void 0, function* () {
          return web3_js_1.PublicKey.findProgramAddress([
            Buffer.from(MetadataProgram.PREFIX, "utf8"),
            MetadataProgram.PUBKEY.toBuffer(),
            mint.toBuffer(),
            Buffer.from(MetadataProgram.USER, "utf8"),
            authority.toBuffer()
          ], MetadataProgram.PUBKEY);
        });
      }
      static findCollectionAuthorityAccount(mint, authority) {
        return __awaiter(this, void 0, void 0, function* () {
          return web3_js_1.PublicKey.findProgramAddress([
            Buffer.from(MetadataProgram.PREFIX, "utf8"),
            MetadataProgram.PUBKEY.toBuffer(),
            mint.toBuffer(),
            Buffer.from(MetadataProgram.COLLECTION_AUTHORITY, "utf8"),
            authority.toBuffer()
          ], MetadataProgram.PUBKEY);
        });
      }
      static findProgramAsBurnerAccount() {
        return __awaiter(this, void 0, void 0, function* () {
          return web3_js_1.PublicKey.findProgramAddress([
            Buffer.from(MetadataProgram.PREFIX, "utf8"),
            MetadataProgram.PUBKEY.toBuffer(),
            Buffer.from(MetadataProgram.BURN, "utf8")
          ], MetadataProgram.PUBKEY);
        });
      }
    };
    exports.MetadataProgram = MetadataProgram;
    MetadataProgram.PREFIX = "metadata";
    MetadataProgram.EDITION = "edition";
    MetadataProgram.USER = "user";
    MetadataProgram.COLLECTION_AUTHORITY = "collection_authority";
    MetadataProgram.BURN = "burn";
    MetadataProgram.PUBKEY = new web3_js_1.PublicKey(mpl_core_1.config.programs.metadata);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/Edition.js
var require_Edition = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/Edition.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Edition = exports.EditionData = void 0;
    var mpl_core_1 = require_mpl_core();
    var MetadataProgram_1 = require_MetadataProgram();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var buffer_1 = require_buffer();
    var constants_1 = require_constants();
    var EditionData = class extends mpl_core_1.Borsh.Data {
      constructor(args) {
        super(args);
        this.key = constants_1.MetadataKey.EditionV1;
      }
    };
    exports.EditionData = EditionData;
    EditionData.SCHEMA = EditionData.struct([
      ["key", "u8"],
      ["parent", "pubkeyAsString"],
      ["edition", "u64"]
    ]);
    var Edition = class extends mpl_core_1.Account {
      constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(MetadataProgram_1.MetadataProgram.PUBKEY)) {
          throw (0, mpl_core_1.ERROR_INVALID_OWNER)();
        }
        if (!Edition.isCompatible(this.info.data)) {
          throw (0, mpl_core_1.ERROR_INVALID_ACCOUNT_DATA)();
        }
        this.data = EditionData.deserialize(this.info.data);
      }
      static getPDA(mint) {
        return __awaiter(this, void 0, void 0, function* () {
          return MetadataProgram_1.MetadataProgram.findProgramAddress([
            buffer_1.Buffer.from(MetadataProgram_1.MetadataProgram.PREFIX),
            MetadataProgram_1.MetadataProgram.PUBKEY.toBuffer(),
            new web3_js_1.PublicKey(mint).toBuffer(),
            buffer_1.Buffer.from(Edition.EDITION_PREFIX)
          ]);
        });
      }
      static isCompatible(data) {
        return data[0] === constants_1.MetadataKey.EditionV1;
      }
    };
    exports.Edition = Edition;
    Edition.EDITION_PREFIX = "edition";
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/MasterEdition.js
var require_MasterEdition = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/MasterEdition.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MasterEdition = exports.MasterEditionV2Data = exports.MasterEditionV1Data = void 0;
    var mpl_core_1 = require_mpl_core();
    var bs58_1 = __importDefault(require_bs58());
    var Edition_1 = require_Edition();
    var MetadataProgram_1 = require_MetadataProgram();
    var buffer_1 = require_buffer();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_1 = require_constants();
    var MasterEditionV1Data = class extends mpl_core_1.Borsh.Data {
      constructor(args) {
        super(args);
        this.key = constants_1.MetadataKey.MasterEditionV1;
      }
    };
    exports.MasterEditionV1Data = MasterEditionV1Data;
    MasterEditionV1Data.SCHEMA = MasterEditionV1Data.struct([
      ["key", "u8"],
      ["supply", "u64"],
      ["maxSupply", { kind: "option", type: "u64" }],
      ["printingMint", "pubkeyAsString"],
      ["oneTimePrintingAuthorizationMint", "pubkeyAsString"]
    ]);
    var MasterEditionV2Data = class extends mpl_core_1.Borsh.Data {
      constructor(args) {
        super(args);
        this.key = constants_1.MetadataKey.MasterEditionV2;
      }
    };
    exports.MasterEditionV2Data = MasterEditionV2Data;
    MasterEditionV2Data.SCHEMA = MasterEditionV2Data.struct([
      ["key", "u8"],
      ["supply", "u64"],
      ["maxSupply", { kind: "option", type: "u64" }]
    ]);
    var MasterEdition = class extends mpl_core_1.Account {
      constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(MetadataProgram_1.MetadataProgram.PUBKEY)) {
          throw (0, mpl_core_1.ERROR_INVALID_OWNER)();
        }
        if (MasterEdition.isMasterEditionV1(this.info.data)) {
          this.data = MasterEditionV1Data.deserialize(this.info.data);
        } else if (MasterEdition.isMasterEditionV2(this.info.data)) {
          this.data = MasterEditionV2Data.deserialize(this.info.data);
        } else {
          throw (0, mpl_core_1.ERROR_INVALID_ACCOUNT_DATA)();
        }
      }
      static getPDA(mint) {
        return __awaiter(this, void 0, void 0, function* () {
          return MetadataProgram_1.MetadataProgram.findProgramAddress([
            buffer_1.Buffer.from(MetadataProgram_1.MetadataProgram.PREFIX),
            MetadataProgram_1.MetadataProgram.PUBKEY.toBuffer(),
            new web3_js_1.PublicKey(mint).toBuffer(),
            buffer_1.Buffer.from(MasterEdition.EDITION_PREFIX)
          ]);
        });
      }
      static isCompatible(data) {
        return MasterEdition.isMasterEditionV1(data) || MasterEdition.isMasterEditionV2(data);
      }
      static isMasterEditionV1(data) {
        return data[0] === constants_1.MetadataKey.MasterEditionV1;
      }
      static isMasterEditionV2(data) {
        return data[0] === constants_1.MetadataKey.MasterEditionV2;
      }
      getEditions(connection) {
        return __awaiter(this, void 0, void 0, function* () {
          return (yield MetadataProgram_1.MetadataProgram.getProgramAccounts(connection, {
            filters: [
              {
                memcmp: {
                  offset: 0,
                  bytes: bs58_1.default.encode(buffer_1.Buffer.from([constants_1.MetadataKey.EditionV1]))
                }
              },
              {
                memcmp: {
                  offset: 1,
                  bytes: this.pubkey.toBase58()
                }
              }
            ]
          })).map((account) => Edition_1.Edition.from(account));
        });
      }
    };
    exports.MasterEdition = MasterEdition;
    MasterEdition.EDITION_PREFIX = "edition";
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/Uses.js
var require_Uses = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/Uses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UseAuthorityRecord = exports.Uses = void 0;
    var mpl_core_1 = require_mpl_core();
    var _1 = require_accounts2();
    var Uses = class extends mpl_core_1.Borsh.Data {
      constructor(args) {
        super(args);
        this.useMethod = args.useMethod;
        this.total = args.total;
        this.remaining = args.remaining;
      }
    };
    exports.Uses = Uses;
    Uses.SCHEMA = Uses.struct([
      ["useMethod", "u8"],
      ["total", "u64"],
      ["remaining", "u64"]
    ]);
    var UseAuthorityRecord = class extends mpl_core_1.Borsh.Data {
      constructor(args) {
        super(args);
        this.key = _1.MetadataKey.UseAuthorityRecord;
        this.allowedUses = args.allowedUses;
        this.bump = args.bump;
      }
    };
    exports.UseAuthorityRecord = UseAuthorityRecord;
    UseAuthorityRecord.SCHEMA = UseAuthorityRecord.struct([
      ["key", "u8"],
      ["allowedUses", "u64"],
      ["bump", "u8"]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/Collection.js
var require_Collection = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/Collection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollctionAuthorityRecord = exports.Collection = void 0;
    var mpl_core_1 = require_mpl_core();
    var constants_1 = require_constants();
    var Collection = class extends mpl_core_1.Borsh.Data {
      constructor(args) {
        super(args);
        this.key = args.key;
        this.verified = args.verified;
      }
    };
    exports.Collection = Collection;
    Collection.SCHEMA = Collection.struct([
      ["verified", "u8"],
      ["key", "pubkeyAsString"]
    ]);
    var CollctionAuthorityRecord = class extends mpl_core_1.Borsh.Data {
      constructor(args) {
        super(args);
        this.key = constants_1.MetadataKey.CollectionAuthorityRecord;
        this.bump = args.bump;
      }
    };
    exports.CollctionAuthorityRecord = CollctionAuthorityRecord;
    CollctionAuthorityRecord.SCHEMA = CollctionAuthorityRecord.struct([
      ["key", "u8"],
      ["bump", "u8"]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/Metadata.js
var require_Metadata = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/Metadata.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeCreatorOffset = exports.MAX_CREATOR_LEN = exports.MAX_URI_LENGTH = exports.MAX_SYMBOL_LENGTH = exports.MAX_NAME_LENGTH = exports.Metadata = exports.MetadataData = exports.MetadataDataData = exports.DataV2 = exports.Creator = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var bn_js_1 = __importDefault(require_bn());
    var bs58_1 = __importDefault(require_bs58());
    var buffer_1 = require_buffer();
    var MetadataProgram_1 = require_MetadataProgram();
    var Edition_1 = require_Edition();
    var MasterEdition_1 = require_MasterEdition();
    var Uses_1 = require_Uses();
    var Collection_1 = require_Collection();
    var constants_1 = require_constants();
    var Creator = class extends mpl_core_1.Borsh.Data {
    };
    exports.Creator = Creator;
    Creator.SCHEMA = Creator.struct([
      ["address", "pubkeyAsString"],
      ["verified", "u8"],
      ["share", "u8"]
    ]);
    var DataV2 = class extends mpl_core_1.Borsh.Data {
    };
    exports.DataV2 = DataV2;
    DataV2.SCHEMA = new Map([
      ...Creator.SCHEMA,
      ...Collection_1.Collection.SCHEMA,
      ...Uses_1.Uses.SCHEMA,
      ...DataV2.struct([
        ["name", "string"],
        ["symbol", "string"],
        ["uri", "string"],
        ["sellerFeeBasisPoints", "u16"],
        ["creators", { kind: "option", type: [Creator] }],
        ["collection", { kind: "option", type: Collection_1.Collection }],
        ["uses", { kind: "option", type: Uses_1.Uses }]
      ])
    ]);
    var MetadataDataData = class extends mpl_core_1.Borsh.Data {
      constructor(args) {
        super(args);
        const METADATA_REPLACE = new RegExp("\0", "g");
        this.name = args.name.replace(METADATA_REPLACE, "");
        this.uri = args.uri.replace(METADATA_REPLACE, "");
        this.symbol = args.symbol.replace(METADATA_REPLACE, "");
      }
    };
    exports.MetadataDataData = MetadataDataData;
    MetadataDataData.SCHEMA = new Map([
      ...Creator.SCHEMA,
      ...MetadataDataData.struct([
        ["name", "string"],
        ["symbol", "string"],
        ["uri", "string"],
        ["sellerFeeBasisPoints", "u16"],
        ["creators", { kind: "option", type: [Creator] }]
      ])
    ]);
    var MetadataData = class extends mpl_core_1.Borsh.Data {
      constructor(args) {
        super(args);
        this.key = constants_1.MetadataKey.MetadataV1;
      }
    };
    exports.MetadataData = MetadataData;
    MetadataData.SCHEMA = new Map([
      ...MetadataDataData.SCHEMA,
      ...Collection_1.Collection.SCHEMA,
      ...Uses_1.Uses.SCHEMA,
      ...MetadataData.struct([
        ["key", "u8"],
        ["updateAuthority", "pubkeyAsString"],
        ["mint", "pubkeyAsString"],
        ["data", MetadataDataData],
        ["primarySaleHappened", "u8"],
        ["isMutable", "u8"],
        ["editionNonce", { kind: "option", type: "u8" }],
        ["tokenStandard", { kind: "option", type: "u8" }],
        ["collection", { kind: "option", type: Collection_1.Collection }],
        ["uses", { kind: "option", type: Uses_1.Uses }]
      ])
    ]);
    var Metadata = class extends mpl_core_1.Account {
      constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetadataProgram_1.MetadataProgram.PUBKEY)) {
          throw (0, mpl_core_1.ERROR_INVALID_OWNER)();
        }
        if (!Metadata.isCompatible(this.info.data)) {
          throw (0, mpl_core_1.ERROR_INVALID_ACCOUNT_DATA)();
        }
        this.data = MetadataData.deserialize(this.info.data);
      }
      static isCompatible(data) {
        return data[0] === constants_1.MetadataKey.MetadataV1;
      }
      static getPDA(mint) {
        return __awaiter(this, void 0, void 0, function* () {
          return MetadataProgram_1.MetadataProgram.findProgramAddress([
            buffer_1.Buffer.from(MetadataProgram_1.MetadataProgram.PREFIX),
            MetadataProgram_1.MetadataProgram.PUBKEY.toBuffer(),
            new web3_js_1.PublicKey(mint).toBuffer()
          ]);
        });
      }
      static findMany(connection, filters = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const baseFilters = [
            {
              memcmp: {
                offset: 0,
                bytes: bs58_1.default.encode(buffer_1.Buffer.from([constants_1.MetadataKey.MetadataV1]))
              }
            },
            filters.updateAuthority && {
              memcmp: {
                offset: 1,
                bytes: new web3_js_1.PublicKey(filters.updateAuthority).toBase58()
              }
            },
            filters.mint && {
              memcmp: {
                offset: 33,
                bytes: new web3_js_1.PublicKey(filters.mint).toBase58()
              }
            }
          ].filter(Boolean);
          if (filters.creators) {
            return (yield Promise.all(Array.from(Array(mpl_core_1.config.maxCreatorLimit).keys()).reduce((prev, i) => [
              ...prev,
              ...filters.creators.map((pubkey) => MetadataProgram_1.MetadataProgram.getProgramAccounts(connection, {
                filters: [
                  ...baseFilters,
                  {
                    memcmp: {
                      offset: (0, exports.computeCreatorOffset)(i),
                      bytes: new web3_js_1.PublicKey(pubkey).toBase58()
                    }
                  }
                ]
              }))
            ], []))).flat().map((account) => Metadata.from(account));
          } else {
            return (yield MetadataProgram_1.MetadataProgram.getProgramAccounts(connection, { filters: baseFilters })).map((account) => Metadata.from(account));
          }
        });
      }
      static findByMint(connection, mint) {
        return __awaiter(this, void 0, void 0, function* () {
          const pda = yield Metadata.getPDA(mint);
          return Metadata.load(connection, pda);
        });
      }
      static findByOwner(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
          const accounts = yield mpl_core_1.TokenAccount.getTokenAccountsByOwner(connection, owner);
          const accountMap = new Map(accounts.map(({ data }) => [data.mint.toString(), data]));
          const allMetadata = yield Metadata.findMany(connection);
          return allMetadata.filter((metadata) => {
            var _a, _b;
            return accountMap.has(metadata.data.mint) && (((_b = (_a = accountMap === null || accountMap === void 0 ? void 0 : accountMap.get(metadata.data.mint)) === null || _a === void 0 ? void 0 : _a.amount) === null || _b === void 0 ? void 0 : _b.toNumber()) || 0) > 0;
          });
        });
      }
      static findByOwnerV2(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
          const accounts = yield mpl_core_1.TokenAccount.getTokenAccountsByOwner(connection, owner);
          const accountsWithAmount = accounts.map(({ data }) => data).filter(({ amount }) => (amount === null || amount === void 0 ? void 0 : amount.toNumber()) > 0);
          return (yield Promise.all(accountsWithAmount.map(({ mint }) => Metadata.findMany(connection, { mint })))).flat();
        });
      }
      static findByOwnerV3(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
          const tokenInfo = yield Metadata.findInfoByOwner(connection, owner);
          return Array.from(tokenInfo.entries()).map(([pubkey, info]) => new Metadata(pubkey, info));
        });
      }
      static findInfoByOwner(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
          const accounts = yield mpl_core_1.TokenAccount.getTokenAccountsByOwner(connection, owner);
          const metadataPdaLookups = accounts.reduce((memo, { data }) => {
            var _a;
            return ((_a = data.amount) === null || _a === void 0 ? void 0 : _a.eq(new bn_js_1.default(1))) ? [...memo, Metadata.getPDA(data.mint)] : memo;
          }, []);
          const metadataAddresses = yield Promise.all(metadataPdaLookups);
          return mpl_core_1.Account.getInfos(connection, metadataAddresses);
        });
      }
      static findDataByOwner(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
          const tokenInfo = yield Metadata.findInfoByOwner(connection, owner);
          return Array.from(tokenInfo.values()).map((m) => MetadataData.deserialize(m.data));
        });
      }
      static getEdition(connection, mint) {
        return __awaiter(this, void 0, void 0, function* () {
          const pda = yield Edition_1.Edition.getPDA(mint);
          const info = yield mpl_core_1.Account.getInfo(connection, pda);
          const key = info === null || info === void 0 ? void 0 : info.data[0];
          switch (key) {
            case constants_1.MetadataKey.EditionV1:
              return new Edition_1.Edition(pda, info);
            case constants_1.MetadataKey.MasterEditionV1:
            case constants_1.MetadataKey.MasterEditionV2:
              return new MasterEdition_1.MasterEdition(pda, info);
            default:
              return;
          }
        });
      }
    };
    exports.Metadata = Metadata;
    exports.MAX_NAME_LENGTH = 32;
    exports.MAX_SYMBOL_LENGTH = 10;
    exports.MAX_URI_LENGTH = 200;
    exports.MAX_CREATOR_LEN = 32 + 1 + 1;
    var computeCreatorOffset = (index) => {
      return 1 + 32 + 32 + 4 + exports.MAX_NAME_LENGTH + 4 + exports.MAX_URI_LENGTH + 4 + exports.MAX_SYMBOL_LENGTH + 2 + 1 + 4 + index * exports.MAX_CREATOR_LEN;
    };
    exports.computeCreatorOffset = computeCreatorOffset;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/EditionMarker.js
var require_EditionMarker = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/EditionMarker.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EditionMarker = exports.EditionMarkerData = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var Edition_1 = require_Edition();
    var MetadataProgram_1 = require_MetadataProgram();
    var buffer_1 = require_buffer();
    var constants_1 = require_constants();
    var EditionMarkerData = class extends mpl_core_1.Borsh.Data {
      constructor(args) {
        super(args);
        this.key = constants_1.MetadataKey.EditionMarker;
      }
      editionTaken(edition) {
        const editionOffset = edition % EditionMarker.DATA_SIZE;
        const indexOffset = Math.floor(editionOffset / 8);
        if (indexOffset > 30) {
          throw Error("Bad index for edition");
        }
        const positionInBitsetFromRight = 7 - editionOffset % 8;
        const mask = Math.pow(2, positionInBitsetFromRight);
        const appliedMask = this.ledger[indexOffset] & mask;
        return appliedMask != 0;
      }
    };
    exports.EditionMarkerData = EditionMarkerData;
    EditionMarkerData.SCHEMA = EditionMarkerData.struct([
      ["key", "u8"],
      ["ledger", [31]]
    ]);
    var EditionMarker = class extends mpl_core_1.Account {
      constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(MetadataProgram_1.MetadataProgram.PUBKEY)) {
          throw (0, mpl_core_1.ERROR_INVALID_OWNER)();
        }
        if (!EditionMarker.isCompatible(this.info.data)) {
          throw (0, mpl_core_1.ERROR_INVALID_ACCOUNT_DATA)();
        }
        this.data = EditionMarkerData.deserialize(this.info.data);
      }
      static getPDA(mint, edition) {
        return __awaiter(this, void 0, void 0, function* () {
          const editionNumber = Math.floor(edition.toNumber() / 248);
          return MetadataProgram_1.MetadataProgram.findProgramAddress([
            buffer_1.Buffer.from(MetadataProgram_1.MetadataProgram.PREFIX),
            MetadataProgram_1.MetadataProgram.PUBKEY.toBuffer(),
            new web3_js_1.PublicKey(mint).toBuffer(),
            buffer_1.Buffer.from(Edition_1.Edition.EDITION_PREFIX),
            buffer_1.Buffer.from(editionNumber.toString())
          ]);
        });
      }
      static isCompatible(data) {
        return data[0] === constants_1.MetadataKey.EditionMarker;
      }
    };
    exports.EditionMarker = EditionMarker;
    EditionMarker.DATA_SIZE = 248;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/index.js
var require_accounts2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/accounts/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_constants(), exports);
    __exportStar(require_Metadata(), exports);
    __exportStar(require_MasterEdition(), exports);
    __exportStar(require_Edition(), exports);
    __exportStar(require_EditionMarker(), exports);
    __exportStar(require_Collection(), exports);
    __exportStar(require_Uses(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/CreateMetadata.js
var require_CreateMetadata = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/CreateMetadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateMetadata = exports.CreateMetadataArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var Metadata_1 = require_Metadata();
    var MetadataProgram_1 = require_MetadataProgram();
    var CreateMetadataArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 0;
      }
    };
    exports.CreateMetadataArgs = CreateMetadataArgs;
    CreateMetadataArgs.SCHEMA = new Map([
      ...Metadata_1.MetadataDataData.SCHEMA,
      ...CreateMetadataArgs.struct([
        ["instruction", "u8"],
        ["data", Metadata_1.MetadataDataData],
        ["isMutable", "u8"]
      ])
    ]);
    var CreateMetadata = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { metadata, metadataData, updateAuthority, mint, mintAuthority } = params;
        const data = CreateMetadataArgs.serialize({
          data: metadataData,
          isMutable: true
        });
        this.add(new web3_js_1.TransactionInstruction({
          keys: [
            {
              pubkey: metadata,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: mint,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: mintAuthority,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: feePayer,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: updateAuthority,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: web3_js_1.SystemProgram.programId,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }
          ],
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.CreateMetadata = CreateMetadata;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/UpdateMetadata.js
var require_UpdateMetadata = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/UpdateMetadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateMetadata = exports.UpdateMetadataArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var Metadata_1 = require_Metadata();
    var MetadataProgram_1 = require_MetadataProgram();
    var UpdateMetadataArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 1;
      }
    };
    exports.UpdateMetadataArgs = UpdateMetadataArgs;
    UpdateMetadataArgs.SCHEMA = new Map([
      ...Metadata_1.MetadataDataData.SCHEMA,
      ...UpdateMetadataArgs.struct([
        ["instruction", "u8"],
        ["data", { kind: "option", type: Metadata_1.MetadataDataData }],
        ["updateAuthority", { kind: "option", type: "pubkeyAsString" }],
        ["primarySaleHappened", { kind: "option", type: "u8" }]
      ])
    ]);
    var UpdateMetadata = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { metadata, metadataData, updateAuthority, newUpdateAuthority, primarySaleHappened } = params;
        const data = UpdateMetadataArgs.serialize({
          data: metadataData,
          updateAuthority: newUpdateAuthority && newUpdateAuthority.toString(),
          primarySaleHappened: primarySaleHappened || null
        });
        this.add(new web3_js_1.TransactionInstruction({
          keys: [
            {
              pubkey: metadata,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: updateAuthority,
              isSigner: true,
              isWritable: false
            }
          ],
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.UpdateMetadata = UpdateMetadata;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/CreateMasterEdition.js
var require_CreateMasterEdition = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/CreateMasterEdition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateMasterEdition = exports.CreateMasterEditionArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var CreateMasterEditionArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 10;
      }
    };
    exports.CreateMasterEditionArgs = CreateMasterEditionArgs;
    CreateMasterEditionArgs.SCHEMA = CreateMasterEditionArgs.struct([
      ["instruction", "u8"],
      ["maxSupply", { kind: "option", type: "u64" }]
    ]);
    var CreateMasterEdition = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { edition, metadata, updateAuthority, mint, mintAuthority, maxSupply } = params;
        const data = CreateMasterEditionArgs.serialize({
          maxSupply: maxSupply || null
        });
        this.add(new web3_js_1.TransactionInstruction({
          keys: [
            {
              pubkey: edition,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: mint,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: updateAuthority,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: mintAuthority,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: feePayer,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: metadata,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: spl_token_1.TOKEN_PROGRAM_ID,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: web3_js_1.SystemProgram.programId,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }
          ],
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.CreateMasterEdition = CreateMasterEdition;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/MintNewEditionFromMasterEditionViaToken.js
var require_MintNewEditionFromMasterEditionViaToken = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/MintNewEditionFromMasterEditionViaToken.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MintNewEditionFromMasterEditionViaToken = exports.MintNewEditionFromMasterEditionViaTokenArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var MintNewEditionFromMasterEditionViaTokenArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 11;
      }
    };
    exports.MintNewEditionFromMasterEditionViaTokenArgs = MintNewEditionFromMasterEditionViaTokenArgs;
    MintNewEditionFromMasterEditionViaTokenArgs.SCHEMA = MintNewEditionFromMasterEditionViaTokenArgs.struct([
      ["instruction", "u8"],
      ["edition", "u64"]
    ]);
    var MintNewEditionFromMasterEditionViaToken = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { edition, metadata, updateAuthority, masterEdition, masterMetadata, mint, editionMarker, mintAuthority, tokenOwner, tokenAccount, editionValue } = params;
        const data = MintNewEditionFromMasterEditionViaTokenArgs.serialize({
          edition: editionValue
        });
        this.add(new web3_js_1.TransactionInstruction({
          keys: [
            {
              pubkey: metadata,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: edition,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: masterEdition,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: mint,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: editionMarker,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: mintAuthority,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: feePayer,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: tokenOwner,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: tokenAccount,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: updateAuthority,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: masterMetadata,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: spl_token_1.TOKEN_PROGRAM_ID,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: web3_js_1.SystemProgram.programId,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }
          ],
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.MintNewEditionFromMasterEditionViaToken = MintNewEditionFromMasterEditionViaToken;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/UpdatePrimarySaleHappenedViaToken.js
var require_UpdatePrimarySaleHappenedViaToken = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/UpdatePrimarySaleHappenedViaToken.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdatePrimarySaleHappenedViaToken = exports.UpdatePrimarySaleHappenedViaTokenArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var UpdatePrimarySaleHappenedViaTokenArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 4;
      }
    };
    exports.UpdatePrimarySaleHappenedViaTokenArgs = UpdatePrimarySaleHappenedViaTokenArgs;
    UpdatePrimarySaleHappenedViaTokenArgs.SCHEMA = UpdatePrimarySaleHappenedViaTokenArgs.struct([["instruction", "u8"]]);
    var UpdatePrimarySaleHappenedViaToken = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { metadata, owner, tokenAccount } = params;
        const data = UpdatePrimarySaleHappenedViaTokenArgs.serialize();
        this.add(new web3_js_1.TransactionInstruction({
          keys: [
            {
              pubkey: metadata,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: owner,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: tokenAccount,
              isSigner: false,
              isWritable: false
            }
          ],
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.UpdatePrimarySaleHappenedViaToken = UpdatePrimarySaleHappenedViaToken;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/SignMetadata.js
var require_SignMetadata = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/SignMetadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignMetadata = exports.SignMetadataArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var SignMetadataArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 7;
      }
    };
    exports.SignMetadataArgs = SignMetadataArgs;
    SignMetadataArgs.SCHEMA = SignMetadataArgs.struct([["instruction", "u8"]]);
    var SignMetadata = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { metadata, creator } = params;
        const data = SignMetadataArgs.serialize();
        this.add(new web3_js_1.TransactionInstruction({
          keys: [
            {
              pubkey: metadata,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: creator,
              isSigner: true,
              isWritable: false
            }
          ],
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.SignMetadata = SignMetadata;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/UpdateMetadataV2.js
var require_UpdateMetadataV2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/UpdateMetadataV2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateMetadataV2 = exports.UpdateMetadataV2Args = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var Metadata_1 = require_Metadata();
    var MetadataProgram_1 = require_MetadataProgram();
    var UpdateMetadataV2Args = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 15;
      }
    };
    exports.UpdateMetadataV2Args = UpdateMetadataV2Args;
    UpdateMetadataV2Args.SCHEMA = new Map([
      ...Metadata_1.DataV2.SCHEMA,
      ...UpdateMetadataV2Args.struct([
        ["instruction", "u8"],
        ["data", { kind: "option", type: Metadata_1.DataV2 }],
        ["updateAuthority", { kind: "option", type: "pubkeyAsString" }],
        ["primarySaleHappened", { kind: "option", type: "u8" }],
        ["isMutable", { kind: "option", type: "u8" }]
      ])
    ]);
    var UpdateMetadataV2 = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { metadata, metadataData, updateAuthority, newUpdateAuthority, primarySaleHappened, isMutable } = params;
        const data = UpdateMetadataV2Args.serialize({
          data: metadataData,
          updateAuthority: newUpdateAuthority && newUpdateAuthority.toString(),
          primarySaleHappened: primarySaleHappened || null,
          isMutable: isMutable || null
        });
        this.add(new web3_js_1.TransactionInstruction({
          keys: [
            {
              pubkey: metadata,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: updateAuthority,
              isSigner: true,
              isWritable: false
            }
          ],
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.UpdateMetadataV2 = UpdateMetadataV2;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/CreateMetadataV2.js
var require_CreateMetadataV2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/CreateMetadataV2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateMetadataV2 = exports.CreateMetadataV2Args = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var Metadata_1 = require_Metadata();
    var MetadataProgram_1 = require_MetadataProgram();
    var CreateMetadataV2Args = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 16;
      }
    };
    exports.CreateMetadataV2Args = CreateMetadataV2Args;
    CreateMetadataV2Args.SCHEMA = new Map([
      ...Metadata_1.DataV2.SCHEMA,
      ...CreateMetadataV2Args.struct([
        ["instruction", "u8"],
        ["data", Metadata_1.DataV2],
        ["isMutable", "u8"]
      ])
    ]);
    var CreateMetadataV2 = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { metadata, metadataData, updateAuthority, mint, mintAuthority } = params;
        const data = CreateMetadataV2Args.serialize({
          data: metadataData,
          isMutable: true
        });
        this.add(new web3_js_1.TransactionInstruction({
          keys: [
            {
              pubkey: metadata,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: mint,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: mintAuthority,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: feePayer,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: updateAuthority,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: web3_js_1.SystemProgram.programId,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }
          ],
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.CreateMetadataV2 = CreateMetadataV2;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/CreateMasterEditionV3.js
var require_CreateMasterEditionV3 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/CreateMasterEditionV3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateMasterEditionV3 = exports.CreateMasterEditionV3Args = void 0;
    var mpl_core_1 = require_mpl_core();
    var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var CreateMasterEditionV3Args = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 17;
      }
    };
    exports.CreateMasterEditionV3Args = CreateMasterEditionV3Args;
    CreateMasterEditionV3Args.SCHEMA = CreateMasterEditionV3Args.struct([
      ["instruction", "u8"],
      ["maxSupply", { kind: "option", type: "u64" }]
    ]);
    var CreateMasterEditionV3 = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { edition, metadata, updateAuthority, mint, mintAuthority, maxSupply } = params;
        const data = CreateMasterEditionV3Args.serialize({
          maxSupply: maxSupply || null
        });
        this.add(new web3_js_1.TransactionInstruction({
          keys: [
            {
              pubkey: edition,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: mint,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: updateAuthority,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: mintAuthority,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: feePayer,
              isSigner: true,
              isWritable: false
            },
            {
              pubkey: metadata,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: spl_token_1.TOKEN_PROGRAM_ID,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: web3_js_1.SystemProgram.programId,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }
          ],
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.CreateMasterEditionV3 = CreateMasterEditionV3;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/VerifyCollection.js
var require_VerifyCollection = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/VerifyCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VerifyCollection = exports.VerifyCollectionArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var VerifyCollectionArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 18;
      }
    };
    exports.VerifyCollectionArgs = VerifyCollectionArgs;
    VerifyCollectionArgs.SCHEMA = new Map([...VerifyCollectionArgs.struct([["instruction", "u8"]])]);
    var VerifyCollection = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { metadata, collectionAuthority, collectionMint, collectionMetadata, collectionMasterEdition, collectionAuthorityRecord } = params;
        const data = VerifyCollectionArgs.serialize();
        const accounts = [
          {
            pubkey: metadata,
            isSigner: false,
            isWritable: true
          },
          {
            pubkey: collectionAuthority,
            isSigner: true,
            isWritable: true
          },
          {
            pubkey: feePayer,
            isSigner: true,
            isWritable: true
          },
          {
            pubkey: collectionMint,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: collectionMetadata,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: collectionMasterEdition,
            isSigner: false,
            isWritable: false
          }
        ];
        if (collectionAuthorityRecord) {
          accounts.push({
            pubkey: collectionAuthorityRecord,
            isSigner: false,
            isWritable: false
          });
        }
        this.add(new web3_js_1.TransactionInstruction({
          keys: accounts,
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.VerifyCollection = VerifyCollection;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/UnverifyCollection.js
var require_UnverifyCollection = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/UnverifyCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnVerifyCollection = exports.UnVerifyCollectionArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var UnVerifyCollectionArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 22;
      }
    };
    exports.UnVerifyCollectionArgs = UnVerifyCollectionArgs;
    UnVerifyCollectionArgs.SCHEMA = new Map([...UnVerifyCollectionArgs.struct([["instruction", "u8"]])]);
    var UnVerifyCollection = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { metadata, collectionAuthority, collectionMint, collectionMetadata, collectionMasterEdition, collectionAuthorityRecord } = params;
        const data = UnVerifyCollectionArgs.serialize();
        const accounts = [
          {
            pubkey: metadata,
            isSigner: false,
            isWritable: true
          },
          {
            pubkey: collectionAuthority,
            isSigner: true,
            isWritable: true
          },
          {
            pubkey: feePayer,
            isSigner: true,
            isWritable: true
          },
          {
            pubkey: collectionMint,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: collectionMetadata,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: collectionMasterEdition,
            isSigner: false,
            isWritable: false
          }
        ];
        if (collectionAuthorityRecord) {
          accounts.push({
            pubkey: collectionAuthorityRecord,
            isSigner: false,
            isWritable: false
          });
        }
        this.add(new web3_js_1.TransactionInstruction({
          keys: accounts,
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.UnVerifyCollection = UnVerifyCollection;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/SetAndVerifyCollection.js
var require_SetAndVerifyCollection = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/SetAndVerifyCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SetAndVerifyCollectionCollection = exports.SetAndVerifyCollectionArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var SetAndVerifyCollectionArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 25;
      }
    };
    exports.SetAndVerifyCollectionArgs = SetAndVerifyCollectionArgs;
    SetAndVerifyCollectionArgs.SCHEMA = new Map([...SetAndVerifyCollectionArgs.struct([["instruction", "u8"]])]);
    var SetAndVerifyCollectionCollection = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { metadata, collectionAuthority, collectionMint, updateAuthority, collectionMetadata, collectionMasterEdition, collectionAuthorityRecord } = params;
        const data = SetAndVerifyCollectionArgs.serialize();
        const accounts = [
          {
            pubkey: metadata,
            isSigner: false,
            isWritable: true
          },
          {
            pubkey: collectionAuthority,
            isSigner: true,
            isWritable: true
          },
          {
            pubkey: feePayer,
            isSigner: true,
            isWritable: true
          },
          {
            pubkey: updateAuthority,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: collectionMint,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: collectionMetadata,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: collectionMasterEdition,
            isSigner: false,
            isWritable: false
          }
        ];
        if (collectionAuthorityRecord) {
          accounts.push({
            pubkey: collectionAuthorityRecord,
            isSigner: false,
            isWritable: false
          });
        }
        this.add(new web3_js_1.TransactionInstruction({
          keys: accounts,
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.SetAndVerifyCollectionCollection = SetAndVerifyCollectionCollection;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/ApproveUseAuthority.js
var require_ApproveUseAuthority = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/ApproveUseAuthority.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ApproveUseAuthority = exports.ApproveUseAuthorityArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var ApproveUseAuthorityArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 20;
      }
    };
    exports.ApproveUseAuthorityArgs = ApproveUseAuthorityArgs;
    ApproveUseAuthorityArgs.SCHEMA = new Map([
      ...ApproveUseAuthorityArgs.struct([
        ["instruction", "u8"],
        ["numberOfUses", "u8"]
      ])
    ]);
    var ApproveUseAuthority = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { useAuthorityRecord, user, owner, ownerTokenAccount, metadata, mint, burner, numberOfUses } = params;
        const data = ApproveUseAuthorityArgs.serialize({ numberOfUses });
        const accounts = [
          {
            pubkey: useAuthorityRecord,
            isSigner: false,
            isWritable: true
          },
          {
            pubkey: owner,
            isSigner: true,
            isWritable: true
          },
          {
            pubkey: feePayer,
            isSigner: true,
            isWritable: true
          },
          {
            pubkey: user,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: ownerTokenAccount,
            isSigner: false,
            isWritable: true
          },
          {
            pubkey: metadata,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: mint,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: burner,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }
        ];
        this.add(new web3_js_1.TransactionInstruction({
          keys: accounts,
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.ApproveUseAuthority = ApproveUseAuthority;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/RevokeUseAuthority.js
var require_RevokeUseAuthority = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/RevokeUseAuthority.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RevokeUseAuthority = exports.RevokeUseAuthorityArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var RevokeUseAuthorityArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 21;
      }
    };
    exports.RevokeUseAuthorityArgs = RevokeUseAuthorityArgs;
    RevokeUseAuthorityArgs.SCHEMA = new Map([...RevokeUseAuthorityArgs.struct([["instruction", "u8"]])]);
    var RevokeUseAuthority = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { useAuthorityRecord, user, owner, ownerTokenAccount, metadata, mint } = params;
        const data = RevokeUseAuthorityArgs.serialize();
        const accounts = [
          {
            pubkey: useAuthorityRecord,
            isSigner: false,
            isWritable: true
          },
          {
            pubkey: owner,
            isSigner: true,
            isWritable: true
          },
          {
            pubkey: user,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: ownerTokenAccount,
            isSigner: false,
            isWritable: true
          },
          {
            pubkey: mint,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: metadata,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }
        ];
        this.add(new web3_js_1.TransactionInstruction({
          keys: accounts,
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.RevokeUseAuthority = RevokeUseAuthority;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/ApproveCollectionAuthority.js
var require_ApproveCollectionAuthority = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/ApproveCollectionAuthority.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ApproveCollectionAuthority = exports.ApproveCollectionAuthorityArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var ApproveCollectionAuthorityArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 23;
      }
    };
    exports.ApproveCollectionAuthorityArgs = ApproveCollectionAuthorityArgs;
    ApproveCollectionAuthorityArgs.SCHEMA = new Map([
      ...ApproveCollectionAuthorityArgs.struct([["instruction", "u8"]])
    ]);
    var ApproveCollectionAuthority = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { metadata, collectionAuthorityRecord, newCollectionAuthority, updateAuthority, mint } = params;
        const data = ApproveCollectionAuthorityArgs.serialize();
        const accounts = [
          {
            pubkey: collectionAuthorityRecord,
            isSigner: false,
            isWritable: true
          },
          {
            pubkey: newCollectionAuthority,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: updateAuthority,
            isSigner: true,
            isWritable: false
          },
          {
            pubkey: feePayer,
            isSigner: true,
            isWritable: true
          },
          {
            pubkey: metadata,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: mint,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }
        ];
        this.add(new web3_js_1.TransactionInstruction({
          keys: accounts,
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.ApproveCollectionAuthority = ApproveCollectionAuthority;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/RevokeCollectionAuthority.js
var require_RevokeCollectionAuthority = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/RevokeCollectionAuthority.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RevokeCollectionAuthority = exports.RevokeCollectionAuthorityArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var RevokeCollectionAuthorityArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 24;
      }
    };
    exports.RevokeCollectionAuthorityArgs = RevokeCollectionAuthorityArgs;
    RevokeCollectionAuthorityArgs.SCHEMA = new Map([
      ...RevokeCollectionAuthorityArgs.struct([["instruction", "u8"]])
    ]);
    var RevokeCollectionAuthority = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { metadata, collectionAuthorityRecord, delegateAuthority, newCollectionAuthority, updateAuthority, mint } = params;
        const delegatedAuth = delegateAuthority || newCollectionAuthority;
        if (!delegatedAuth) {
          throw new Error("Must provide either a delegateAuthority");
        }
        const data = RevokeCollectionAuthorityArgs.serialize();
        const accounts = [
          {
            pubkey: collectionAuthorityRecord,
            isSigner: false,
            isWritable: true
          },
          {
            pubkey: delegatedAuth,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: updateAuthority,
            isSigner: true,
            isWritable: false
          },
          {
            pubkey: metadata,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: mint,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }
        ];
        this.add(new web3_js_1.TransactionInstruction({
          keys: accounts,
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.RevokeCollectionAuthority = RevokeCollectionAuthority;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/Utilize.js
var require_Utilize = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/Utilize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Utilize = exports.UtilizeArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var UtilizeArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 19;
      }
    };
    exports.UtilizeArgs = UtilizeArgs;
    UtilizeArgs.SCHEMA = new Map([
      ...UtilizeArgs.struct([
        ["instruction", "u8"],
        ["numberOfUses", "u8"]
      ])
    ]);
    var Utilize = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { metadata, useAuthority, numberOfUses, burner, tokenAccount } = params;
        const data = UtilizeArgs.serialize({ numberOfUses });
        const accounts = [
          {
            pubkey: metadata,
            isSigner: false,
            isWritable: true
          },
          {
            pubkey: tokenAccount,
            isSigner: false,
            isWritable: true
          },
          {
            pubkey: useAuthority,
            isSigner: true,
            isWritable: false
          },
          {
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: web3_js_1.SystemProgram.programId,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: web3_js_1.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }
        ];
        if (useAuthority) {
          accounts.push({
            pubkey: useAuthority,
            isSigner: false,
            isWritable: false
          });
          accounts.push({
            pubkey: burner,
            isSigner: false,
            isWritable: false
          });
        }
        this.add(new web3_js_1.TransactionInstruction({
          keys: accounts,
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.Utilize = Utilize;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/FreezeDelegatedAccount.js
var require_FreezeDelegatedAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/FreezeDelegatedAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FreezeDelegatedAccount = exports.FreezeDelegatedAccountArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
    var FreezeDelegatedAccountArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 26;
      }
    };
    exports.FreezeDelegatedAccountArgs = FreezeDelegatedAccountArgs;
    FreezeDelegatedAccountArgs.SCHEMA = new Map([...FreezeDelegatedAccountArgs.struct([["instruction", "u8"]])]);
    var FreezeDelegatedAccount = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { delegate, token_account, edition, mint } = params;
        const data = FreezeDelegatedAccountArgs.serialize();
        this.add(new web3_js_1.TransactionInstruction({
          keys: [
            {
              pubkey: delegate,
              isSigner: true,
              isWritable: true
            },
            {
              pubkey: token_account,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: edition,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: mint,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: spl_token_1.TOKEN_PROGRAM_ID,
              isSigner: false,
              isWritable: false
            }
          ],
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.FreezeDelegatedAccount = FreezeDelegatedAccount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/ThawDelegatedAccount.js
var require_ThawDelegatedAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/ThawDelegatedAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ThawDelegatedAccount = exports.ThawDelegatedAccountArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
    var ThawDelegatedAccountArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 27;
      }
    };
    exports.ThawDelegatedAccountArgs = ThawDelegatedAccountArgs;
    ThawDelegatedAccountArgs.SCHEMA = new Map([...ThawDelegatedAccountArgs.struct([["instruction", "u8"]])]);
    var ThawDelegatedAccount = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { delegate, token_account, edition, mint } = params;
        const data = ThawDelegatedAccountArgs.serialize();
        this.add(new web3_js_1.TransactionInstruction({
          keys: [
            {
              pubkey: delegate,
              isSigner: true,
              isWritable: true
            },
            {
              pubkey: token_account,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: edition,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: mint,
              isSigner: false,
              isWritable: false
            },
            {
              pubkey: spl_token_1.TOKEN_PROGRAM_ID,
              isSigner: false,
              isWritable: false
            }
          ],
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.ThawDelegatedAccount = ThawDelegatedAccount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/RemoveCreatorVerification.js
var require_RemoveCreatorVerification = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/RemoveCreatorVerification.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RemoveCreatorVerification = exports.RemoveCreatorVerificationArgs = void 0;
    var mpl_core_1 = require_mpl_core();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var MetadataProgram_1 = require_MetadataProgram();
    var RemoveCreatorVerificationArgs = class extends mpl_core_1.Borsh.Data {
      constructor() {
        super(...arguments);
        this.instruction = 28;
      }
    };
    exports.RemoveCreatorVerificationArgs = RemoveCreatorVerificationArgs;
    RemoveCreatorVerificationArgs.SCHEMA = RemoveCreatorVerificationArgs.struct([["instruction", "u8"]]);
    var RemoveCreatorVerification = class extends mpl_core_1.Transaction {
      constructor(options, params) {
        super(options);
        const { metadata, creator } = params;
        const data = RemoveCreatorVerificationArgs.serialize();
        this.add(new web3_js_1.TransactionInstruction({
          keys: [
            {
              pubkey: metadata,
              isSigner: false,
              isWritable: true
            },
            {
              pubkey: creator,
              isSigner: true,
              isWritable: false
            }
          ],
          programId: MetadataProgram_1.MetadataProgram.PUBKEY,
          data
        }));
      }
    };
    exports.RemoveCreatorVerification = RemoveCreatorVerification;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/index.js
var require_transactions = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/transactions/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_CreateMetadata(), exports);
    __exportStar(require_UpdateMetadata(), exports);
    __exportStar(require_CreateMasterEdition(), exports);
    __exportStar(require_MintNewEditionFromMasterEditionViaToken(), exports);
    __exportStar(require_UpdatePrimarySaleHappenedViaToken(), exports);
    __exportStar(require_SignMetadata(), exports);
    __exportStar(require_UpdateMetadataV2(), exports);
    __exportStar(require_CreateMetadataV2(), exports);
    __exportStar(require_CreateMasterEditionV3(), exports);
    __exportStar(require_VerifyCollection(), exports);
    __exportStar(require_UnverifyCollection(), exports);
    __exportStar(require_SignMetadata(), exports);
    __exportStar(require_SetAndVerifyCollection(), exports);
    __exportStar(require_ApproveUseAuthority(), exports);
    __exportStar(require_RevokeUseAuthority(), exports);
    __exportStar(require_ApproveCollectionAuthority(), exports);
    __exportStar(require_RevokeCollectionAuthority(), exports);
    __exportStar(require_Utilize(), exports);
    __exportStar(require_FreezeDelegatedAccount(), exports);
    __exportStar(require_ThawDelegatedAccount(), exports);
    __exportStar(require_RemoveCreatorVerification(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/mpl-token-metadata.js
var require_mpl_token_metadata = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/mpl-token-metadata.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_accounts2(), exports);
    __exportStar(require_MetadataProgram(), exports);
    __exportStar(require_transactions(), exports);
  }
});

// dep:@metaplex-foundation_mpl-token-metadata
var metaplex_foundation_mpl_token_metadata_default = require_mpl_token_metadata();
export {
  metaplex_foundation_mpl_token_metadata_default as default
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
//# sourceMappingURL=@metaplex-foundation_mpl-token-metadata.js.map
