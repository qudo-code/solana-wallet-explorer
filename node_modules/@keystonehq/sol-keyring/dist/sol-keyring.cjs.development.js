'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var bcUrRegistrySol = require('@keystonehq/bc-ur-registry-sol');
var sdk = require('@keystonehq/sdk');
var sdk__default = _interopDefault(sdk);
var bcUrRegistry = require('@keystonehq/bc-ur-registry');
var bs58 = _interopDefault(require('bs58'));
var uuid = require('uuid');
var web3_js = require('@solana/web3.js');

class DefaultInteractionProvider {
  constructor() {
    this.keystoneSDK = undefined;

    this.readCryptoMultiAccounts = async () => {
      const decodedResult = await this.keystoneSDK.read([sdk.SupportedResult.UR_CRYPTO_MULTI_ACCOUNTS], {
        title: "Sync Keystone",
        description: "Please scan the QR code displayed on your Keystone",
        renderInitial: {
          walletMode: "Solflare",
          link: "https://keyst.one/defi"
        },
        URTypeErrorMessage: "The scanned QR code is not the sync code from the Keystone hardware wallet. Please verify the code and try again"
      });

      if (decodedResult.status === sdk.ReadStatus.success) {
        const {
          result
        } = decodedResult;
        return bcUrRegistry.CryptoMultiAccounts.fromCBOR(result.cbor);
      } else {
        throw new Error("Reading canceled");
      }
    };

    this.requestSignature = async (solSignRequest, requestTitle, requestDescription) => {
      const status = await this.keystoneSDK.play(solSignRequest.toUR(), {
        hasNext: true,
        title: requestTitle,
        description: requestDescription,
        maxFragmentLength: 400
      });
      if (status === sdk.PlayStatus.canceled) throw new Error("#ktek_error[play-cancel]: play canceled");
      const result = await this.keystoneSDK.read([sdk.SupportedResult.UR_SOL_SIGNATURE], {
        title: "Scan Keystone",
        description: "Please scan the QR code displayed on your Keystone"
      });

      if (result.status === sdk.ReadStatus.canceled) {
        throw new Error("#ktek_error[read-cancel]: read signature canceled");
      } else {
        return bcUrRegistrySol.SolSignature.fromCBOR(result.result.cbor);
      }
    };

    if (DefaultInteractionProvider.instance) {
      return DefaultInteractionProvider.instance;
    }

    sdk__default.bootstrap();
    this.keystoneSDK = sdk__default.getSdk();
    DefaultInteractionProvider.instance = this;
  }

}

const keyringType = "QR Hardware Wallet Device";
class BaseKeyring {
  constructor() {
    this.getInteraction = () => {
      throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.");
    };

    this.type = keyringType;

    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {
      const solSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);
      const requestIdBuffer = solSignature.getRequestId();
      const signature = solSignature.getSignature();

      if (requestIdBuffer) {
        const requestId = uuid.stringify(requestIdBuffer);

        if (requestId !== _requestId) {
          throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");
        }
      }

      return signature;
    };

    this.getName = () => {
      return this.name;
    }; //common props


    this.keys = [];
    this.name = "QR Hardware";
    this.initialized = false;
    this.device = "";
    this.xfp = "";
  } //initial read


  async readKeyring() {
    const result = await this.getInteraction().readCryptoMultiAccounts();
    this.syncKeyring(result);
  }

  syncKeyring(data) {
    var _data$getKeys$0$getOr;

    const keys = data.getKeys();
    this.device = data.getDevice();
    this.xfp = (_data$getKeys$0$getOr = data.getKeys()[0].getOrigin().getSourceFingerprint()) == null ? void 0 : _data$getKeys$0$getOr.toString("hex");
    this.name = data.getKeys()[0].getName();
    this.keys = keys.map((each, index) => ({
      hdPath: each.getOrigin().getPath(),
      pubKey: bs58.encode(each.getKey()),
      index
    }));
    this.initialized = true;
  }

  syncKeyringData({
    xfp,
    keys,
    name = "QR Hardware",
    device
  }) {
    this.xfp = xfp;
    this.name = name;
    this.keys = keys;
    this.device = device;
    this.initialized = true;
  }

  getAccounts() {
    if (!this.initialized) {
      return [];
    }

    return this.keys;
  }

  async signTransaction(pubKey, tx) {
    const signature = await this._getSignature(pubKey, Buffer.from(tx.serializeMessage()), bcUrRegistrySol.SignType.Transaction);
    tx.addSignature(new web3_js.PublicKey(pubKey), signature);
    return tx;
  }

  async signMessage(pubKey, messageHex) {
    return await this._getSignature(pubKey, Buffer.from(messageHex), bcUrRegistrySol.SignType.Message);
  }

  async createSignature(pubKey, messageHex) {
    try {
      const messageInstance = web3_js.Message.from(messageHex);
      const transaction = web3_js.Transaction.populate(messageInstance, []);

      if (transaction) {
        return this._getSignature(pubKey, Buffer.from(messageHex), bcUrRegistrySol.SignType.Transaction);
      }
    } catch (e) {}

    return this.signMessage(pubKey, messageHex);
  }

  async _getSignature(pubKey, messageHex, signType) {
    const requestId = uuid.v4();
    const account = this.getAccounts().find(account => account.pubKey == pubKey);
    const solSignRequest = bcUrRegistrySol.SolSignRequest.constructSOLRequest(messageHex, account.hdPath, this.xfp, signType, requestId);
    return this.requestSignature(requestId, solSignRequest, "Scan with your Keystone", 'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');
  }

}
BaseKeyring.type = keyringType;

class DefaultKeyring extends BaseKeyring {
  constructor() {
    super();

    this.getInteraction = () => {
      return new DefaultInteractionProvider();
    };
  }

  static getEmptyKeyring() {
    return new DefaultKeyring();
  }

}
DefaultKeyring.type = BaseKeyring.type;

exports.BaseKeyring = BaseKeyring;
exports.DefaultKeyring = DefaultKeyring;
//# sourceMappingURL=sol-keyring.cjs.development.js.map
