"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var t=require("@keystonehq/bc-ur-registry-sol"),r=require("@keystonehq/sdk"),s=e(r),n=require("@keystonehq/bc-ur-registry"),i=e(require("bs58")),a=require("uuid"),o=require("@solana/web3.js");class c{constructor(){if(this.keystoneSDK=void 0,this.readCryptoMultiAccounts=async()=>{const e=await this.keystoneSDK.read([r.SupportedResult.UR_CRYPTO_MULTI_ACCOUNTS],{title:"Sync Keystone",description:"Please scan the QR code displayed on your Keystone",renderInitial:{walletMode:"Solflare",link:"https://keyst.one/defi"},URTypeErrorMessage:"The scanned QR code is not the sync code from the Keystone hardware wallet. Please verify the code and try again"});if(e.status===r.ReadStatus.success){const{result:t}=e;return n.CryptoMultiAccounts.fromCBOR(t.cbor)}throw new Error("Reading canceled")},this.requestSignature=async(e,s,n)=>{if(await this.keystoneSDK.play(e.toUR(),{hasNext:!0,title:s,description:n,maxFragmentLength:400})===r.PlayStatus.canceled)throw new Error("#ktek_error[play-cancel]: play canceled");const i=await this.keystoneSDK.read([r.SupportedResult.UR_SOL_SIGNATURE],{title:"Scan Keystone",description:"Please scan the QR code displayed on your Keystone"});if(i.status===r.ReadStatus.canceled)throw new Error("#ktek_error[read-cancel]: read signature canceled");return t.SolSignature.fromCBOR(i.result.cbor)},c.instance)return c.instance;s.bootstrap(),this.keystoneSDK=s.getSdk(),c.instance=this}}class u{constructor(){this.getInteraction=()=>{throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.")},this.type="QR Hardware Wallet Device",this.requestSignature=async(e,t,r,s)=>{const n=await this.getInteraction().requestSignature(t,r,s),i=n.getRequestId(),o=n.getSignature();if(i&&a.stringify(i)!==e)throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");return o},this.getName=()=>this.name,this.keys=[],this.name="QR Hardware",this.initialized=!1,this.device="",this.xfp=""}async readKeyring(){const e=await this.getInteraction().readCryptoMultiAccounts();this.syncKeyring(e)}syncKeyring(e){var t;const r=e.getKeys();this.device=e.getDevice(),this.xfp=null==(t=e.getKeys()[0].getOrigin().getSourceFingerprint())?void 0:t.toString("hex"),this.name=e.getKeys()[0].getName(),this.keys=r.map((e,t)=>({hdPath:e.getOrigin().getPath(),pubKey:i.encode(e.getKey()),index:t})),this.initialized=!0}syncKeyringData({xfp:e,keys:t,name:r="QR Hardware",device:s}){this.xfp=e,this.name=r,this.keys=t,this.device=s,this.initialized=!0}getAccounts(){return this.initialized?this.keys:[]}async signTransaction(e,r){const s=await this._getSignature(e,Buffer.from(r.serializeMessage()),t.SignType.Transaction);return r.addSignature(new o.PublicKey(e),s),r}async signMessage(e,r){return await this._getSignature(e,Buffer.from(r),t.SignType.Message)}async createSignature(e,r){try{const s=o.Message.from(r);if(o.Transaction.populate(s,[]))return this._getSignature(e,Buffer.from(r),t.SignType.Transaction)}catch(e){}return this.signMessage(e,r)}async _getSignature(e,r,s){const n=a.v4(),i=this.getAccounts().find(t=>t.pubKey==e),o=t.SolSignRequest.constructSOLRequest(r,i.hdPath,this.xfp,s,n);return this.requestSignature(n,o,"Scan with your Keystone",'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature')}}u.type="QR Hardware Wallet Device";class y extends u{constructor(){super(),this.getInteraction=()=>new c}static getEmptyKeyring(){return new y}}y.type=u.type,exports.BaseKeyring=u,exports.DefaultKeyring=y;
//# sourceMappingURL=sol-keyring.cjs.production.min.js.map
