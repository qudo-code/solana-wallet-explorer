import { SolSignature, SignType, SolSignRequest } from '@keystonehq/bc-ur-registry-sol';
import sdk, { SupportedResult, ReadStatus, PlayStatus } from '@keystonehq/sdk';
import { CryptoMultiAccounts } from '@keystonehq/bc-ur-registry';
import bs58 from 'bs58';
import { stringify, v4 } from 'uuid';
import { PublicKey, Message, Transaction } from '@solana/web3.js';

class DefaultInteractionProvider {
  constructor() {
    this.keystoneSDK = undefined;

    this.readCryptoMultiAccounts = async () => {
      const decodedResult = await this.keystoneSDK.read([SupportedResult.UR_CRYPTO_MULTI_ACCOUNTS], {
        title: "Sync Keystone",
        description: "Please scan the QR code displayed on your Keystone",
        renderInitial: {
          walletMode: "Solflare",
          link: "https://keyst.one/defi"
        },
        URTypeErrorMessage: "The scanned QR code is not the sync code from the Keystone hardware wallet. Please verify the code and try again"
      });

      if (decodedResult.status === ReadStatus.success) {
        const {
          result
        } = decodedResult;
        return CryptoMultiAccounts.fromCBOR(result.cbor);
      } else {
        throw new Error("Reading canceled");
      }
    };

    this.requestSignature = async (solSignRequest, requestTitle, requestDescription) => {
      const status = await this.keystoneSDK.play(solSignRequest.toUR(), {
        hasNext: true,
        title: requestTitle,
        description: requestDescription,
        maxFragmentLength: 400
      });
      if (status === PlayStatus.canceled) throw new Error("#ktek_error[play-cancel]: play canceled");
      const result = await this.keystoneSDK.read([SupportedResult.UR_SOL_SIGNATURE], {
        title: "Scan Keystone",
        description: "Please scan the QR code displayed on your Keystone"
      });

      if (result.status === ReadStatus.canceled) {
        throw new Error("#ktek_error[read-cancel]: read signature canceled");
      } else {
        return SolSignature.fromCBOR(result.result.cbor);
      }
    };

    if (DefaultInteractionProvider.instance) {
      return DefaultInteractionProvider.instance;
    }

    sdk.bootstrap();
    this.keystoneSDK = sdk.getSdk();
    DefaultInteractionProvider.instance = this;
  }

}

const keyringType = "QR Hardware Wallet Device";
class BaseKeyring {
  constructor() {
    this.getInteraction = () => {
      throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.");
    };

    this.type = keyringType;

    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {
      const solSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);
      const requestIdBuffer = solSignature.getRequestId();
      const signature = solSignature.getSignature();

      if (requestIdBuffer) {
        const requestId = stringify(requestIdBuffer);

        if (requestId !== _requestId) {
          throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");
        }
      }

      return signature;
    };

    this.getName = () => {
      return this.name;
    }; //common props


    this.keys = [];
    this.name = "QR Hardware";
    this.initialized = false;
    this.device = "";
    this.xfp = "";
  } //initial read


  async readKeyring() {
    const result = await this.getInteraction().readCryptoMultiAccounts();
    this.syncKeyring(result);
  }

  syncKeyring(data) {
    var _data$getKeys$0$getOr;

    const keys = data.getKeys();
    this.device = data.getDevice();
    this.xfp = (_data$getKeys$0$getOr = data.getKeys()[0].getOrigin().getSourceFingerprint()) == null ? void 0 : _data$getKeys$0$getOr.toString("hex");
    this.name = data.getKeys()[0].getName();
    this.keys = keys.map((each, index) => ({
      hdPath: each.getOrigin().getPath(),
      pubKey: bs58.encode(each.getKey()),
      index
    }));
    this.initialized = true;
  }

  syncKeyringData({
    xfp,
    keys,
    name = "QR Hardware",
    device
  }) {
    this.xfp = xfp;
    this.name = name;
    this.keys = keys;
    this.device = device;
    this.initialized = true;
  }

  getAccounts() {
    if (!this.initialized) {
      return [];
    }

    return this.keys;
  }

  async signTransaction(pubKey, tx) {
    const signature = await this._getSignature(pubKey, Buffer.from(tx.serializeMessage()), SignType.Transaction);
    tx.addSignature(new PublicKey(pubKey), signature);
    return tx;
  }

  async signMessage(pubKey, messageHex) {
    return await this._getSignature(pubKey, Buffer.from(messageHex), SignType.Message);
  }

  async createSignature(pubKey, messageHex) {
    try {
      const messageInstance = Message.from(messageHex);
      const transaction = Transaction.populate(messageInstance, []);

      if (transaction) {
        return this._getSignature(pubKey, Buffer.from(messageHex), SignType.Transaction);
      }
    } catch (e) {}

    return this.signMessage(pubKey, messageHex);
  }

  async _getSignature(pubKey, messageHex, signType) {
    const requestId = v4();
    const account = this.getAccounts().find(account => account.pubKey == pubKey);
    const solSignRequest = SolSignRequest.constructSOLRequest(messageHex, account.hdPath, this.xfp, signType, requestId);
    return this.requestSignature(requestId, solSignRequest, "Scan with your Keystone", 'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');
  }

}
BaseKeyring.type = keyringType;

class DefaultKeyring extends BaseKeyring {
  constructor() {
    super();

    this.getInteraction = () => {
      return new DefaultInteractionProvider();
    };
  }

  static getEmptyKeyring() {
    return new DefaultKeyring();
  }

}
DefaultKeyring.type = BaseKeyring.type;

export { BaseKeyring, DefaultKeyring };
//# sourceMappingURL=sol-keyring.esm.js.map
