"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = void 0;
const uuid_1 = require("uuid");
const crypto_js_1 = __importDefault(require("crypto-js"));
const events_1 = require("events");
const types_1 = require("./types");
const utils_1 = require("./utils");
class Auth {
    constructor(config) {
        this.config = config;
        this.userStore = "particle_user_info";
        this.events = new events_1.EventEmitter();
        this.secretKey = "";
        this._authResult = null;
        this.uiMode = "auto";
        this.displayCloseButton = true;
        this.config = config;
        window.addEventListener("message", (event) => {
            if (event.data.name && event.data.name === "particle-network-provider" && this._authResult) {
                const data = this.decrypt(event.data.data);
                if (data.token && data.uuid) {
                    this.setUserInfo(data);
                }
                if (data.wallets) {
                    const userInfo = this.userInfo();
                    if (userInfo) {
                        userInfo.wallets = data.wallets;
                        this.setUserInfo(userInfo);
                    }
                }
                if (data.error) {
                    if (data.error.code === 8005 || data.error.code === 10005) {
                        this.setUserInfo(null);
                        this.events.emit("disconnect");
                    }
                    this._authResult.reject(data.error);
                }
                else {
                    this._authResult.resolve(data);
                }
                this._authResult.iframe.remove();
                this._authResult = null;
                const container = document.getElementById("particle-network-container");
                if (container) {
                    container.style.display = "none";
                }
            }
        });
    }
    login(config) {
        var _a;
        const iframe = this.getIframe();
        iframe.src = this.buildUrl("/login", {
            login_type: config === null || config === void 0 ? void 0 : config.preferredAuthType,
            support_auth_types: (_a = config === null || config === void 0 ? void 0 : config.supportAuthTypes) !== null && _a !== void 0 ? _a : "all",
            account: config === null || config === void 0 ? void 0 : config.emailOrPhoneAccount,
            login_form_mode: config === null || config === void 0 ? void 0 : config.loginFormMode,
        });
        return new Promise((resolve, reject) => {
            this.setAuthResult({
                resolve: (value) => {
                    this.events.emit("connect", value);
                    resolve(value);
                },
                reject,
                iframe,
            });
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            const iframe = this.getIframe();
            iframe.src = this.buildUrl("/logout");
            return new Promise((resolve, reject) => {
                this.setAuthResult({
                    resolve: () => {
                        this.setUserInfo(null);
                        this.events.emit("disconnect");
                        resolve();
                    },
                    reject,
                    iframe,
                });
            });
        });
    }
    sign(method, message) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.walletExist()) {
                return Promise.reject(types_1.AuthError.walletNotCreated());
            }
            const iframe = this.getIframe();
            if (this.config.chainName === "solana") {
                iframe.src = this.buildUrl("/solana/sign", {
                    token: (_a = this.userInfo()) === null || _a === void 0 ? void 0 : _a.token,
                    method: method,
                    chain_id: Number(this.config.chainId),
                    message: message,
                });
            }
            else {
                iframe.src = this.buildUrl("/evm-chain/sign", {
                    token: (_b = this.userInfo()) === null || _b === void 0 ? void 0 : _b.token,
                    method: method,
                    chain_id: Number(this.config.chainId),
                    message: message,
                });
            }
            return new Promise((resolve, reject) => {
                this.setAuthResult({
                    resolve: (value) => {
                        var _a;
                        resolve((_a = value.signature) !== null && _a !== void 0 ? _a : "");
                    },
                    reject,
                    iframe,
                });
            });
        });
    }
    signAllTransactions(messages) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.walletExist()) {
                return Promise.reject(types_1.AuthError.walletNotCreated());
            }
            if (this.config.chainName !== "solana") {
                return Promise.reject(types_1.AuthError.unsupportedMethod());
            }
            const result = yield this.sign("signAllTransactions", JSON.stringify(messages));
            const signatures = JSON.parse(result);
            return signatures;
        });
    }
    sendTransaction(message) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.walletExist()) {
                return Promise.reject(types_1.AuthError.walletNotCreated());
            }
            if (this.config.chainName === "solana") {
                return this.sign("signAndSendTransaction", message);
            }
            else {
                const iframe = this.getIframe();
                iframe.src = this.buildUrl("/evm-chain/sign", {
                    token: (_a = this.userInfo()) === null || _a === void 0 ? void 0 : _a.token,
                    method: "eth_sendTransaction",
                    chain_id: Number(this.config.chainId),
                    message: message,
                });
                return new Promise((resolve, reject) => {
                    this.setAuthResult({
                        resolve: (value) => {
                            var _a;
                            resolve((_a = value.signature) !== null && _a !== void 0 ? _a : "");
                        },
                        reject,
                        iframe,
                    });
                });
            }
        });
    }
    setChainInfo(chain) {
        const userInfo = this.userInfo();
        if (!userInfo) {
            return Promise.reject(types_1.AuthError.notLogin());
        }
        if (typeof chain.name !== "string" || typeof chain.id !== "number") {
            throw types_1.AuthError.paramsError();
        }
        if (!Object.keys(types_1.supportChains).includes(chain.name)) {
            throw types_1.AuthError.unsupportedChain();
        }
        const chainName = chain.name;
        if (!types_1.supportChains[chainName].includes(chain.id)) {
            throw types_1.AuthError.unsupportedChain();
        }
        const wallets = userInfo.wallets;
        if (this.config.chainName === chain.name && this.config.chainId === chain.id) {
            return Promise.resolve(wallets);
        }
        const wallet = this.wallet(chainName === "solana" ? "solana" : "evm_chain");
        if (wallet) {
            this.config.chainName = chain.name;
            this.config.chainId = chain.id;
            this.events.emit("chainChanged", chain);
            return Promise.resolve(wallets);
        }
        //create wallet
        const iframe = this.getIframe();
        iframe.src = this.buildUrl("/wallet", {
            token: userInfo.token,
            chain_name: chain.name,
        });
        return new Promise((resolve, reject) => {
            this.setAuthResult({
                resolve: (value) => {
                    this.config.chainName = chain.name;
                    this.config.chainId = chain.id;
                    this.events.emit("connect", this.userInfo());
                    this.events.emit("chainChanged", chain);
                    resolve(value);
                },
                reject,
                iframe,
            });
        });
    }
    chainId() {
        return this.config.chainId;
    }
    basicCredentials() {
        return `Basic ${Buffer.from(`${this.config.projectId}:${this.config.clientKey}`, "utf8").toString("base64")}`;
    }
    isLogin() {
        return this.userInfo() !== null;
    }
    userInfo() {
        const info = window.localStorage.getItem(this.userStore);
        return info ? JSON.parse(info) : null;
    }
    walletExist() {
        return this.wallet() != null;
    }
    wallet(chainType) {
        const userInfo = this.userInfo();
        if (!userInfo) {
            return null;
        }
        const wallet = userInfo.wallets.find((wallet) => wallet.chain_name === (chainType || this.walletChainName()));
        if (wallet !== undefined && wallet.public_address.length > 0) {
            return wallet;
        }
        return null;
    }
    setAuthTheme(config) {
        if (config.uiMode) {
            this.uiMode = config.uiMode;
        }
        if (config.displayCloseButton !== null && config.displayCloseButton !== undefined) {
            this.displayCloseButton = config.displayCloseButton;
        }
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    walletChainName() {
        return this.config.chainName === "solana" ? "solana" : "evm_chain";
    }
    setAuthResult(authResult) {
        if (this._authResult) {
            this._authResult.reject(types_1.AuthError.userCancelOperation());
        }
        this._authResult = authResult;
    }
    setUserInfo(info) {
        if (info) {
            window.localStorage.setItem(this.userStore, JSON.stringify(info));
        }
        else {
            window.localStorage.removeItem(this.userStore);
        }
    }
    getIframe() {
        let containerDiv = document.getElementById("particle-network-container");
        if (!containerDiv) {
            containerDiv = document.createElement("div");
            containerDiv.setAttribute("style", "display: block;position: fixed;top: 0px;right: 0px;width: 100%;height: 100%;border-radius: 0px;border: none;z-index: 2147483647;background-color: rgba(0, 0, 0, 0.5);align-items: center;");
            containerDiv.id = "particle-network-container";
            document.body.appendChild(containerDiv);
        }
        else {
            containerDiv.style.display = "block";
        }
        let iframe;
        const elements = document.getElementsByName("particle-network-iframe");
        if (elements.length > 0) {
            iframe = elements[0];
            iframe.style.display = "";
        }
        else {
            iframe = document.createElement("iframe");
            iframe.name = "particle-network-iframe";
            let bgColor = "background-color: #FFFFFF";
            const themeType = this.getThemeType();
            if (themeType === "dark") {
                bgColor = "background-color: #000000";
            }
            iframe.setAttribute("style", "position: absolute;left: 50%;top: 50%;transform: translate(-50%, -50%);width: 400px;height: 650px;border-radius: 0px;border: none;z-index: 2147483647;box-shadow: -1px 3px 11px 2px #00000073;border-radius: 10px;" +
                bgColor);
            containerDiv.appendChild(iframe);
        }
        return iframe;
    }
    buildUrl(path, extraParams = {}) {
        var _a;
        const schema = (_a = this.config.authUrl) !== null && _a !== void 0 ? _a : "https://auth.particle.network";
        const params = {
            project_uuid: this.config.projectId,
            project_client_key: this.config.clientKey,
            project_app_uuid: this.config.appId,
            chain_name: this.config.chainName,
            sdk_version: (0, utils_1.getVersion)(),
            device_id: (0, utils_1.getDeviceId)(),
            display_close_button: this.displayCloseButton,
        };
        Object.assign(params, Object.assign({}, extraParams));
        this.secretKey = (0, uuid_1.v4)().replace(/-/g, "").toUpperCase();
        const keyWA = crypto_js_1.default.enc.Utf8.parse(this.secretKey);
        const cipherText = crypto_js_1.default.AES.encrypt(JSON.stringify(params), keyWA, {
            mode: crypto_js_1.default.mode.ECB,
            algorithm: crypto_js_1.default.algo.AES,
            padding: crypto_js_1.default.pad.Pkcs7,
            formatter: crypto_js_1.default.format.Hex,
        }).ciphertext;
        const value = encodeURIComponent(crypto_js_1.default.enc.Base64.stringify(cipherText)) + this.secretKey;
        const url = `${schema}?params=${value}&encoding=base64&theme_type=${this.getThemeType()}#${path}`;
        return url;
    }
    getThemeType() {
        return this.uiMode === "auto"
            ? window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches
                ? "dark"
                : "light"
            : this.uiMode;
    }
    decrypt(data) {
        const dec = crypto_js_1.default.enc.Hex.parse(data);
        const keyWA = crypto_js_1.default.enc.Utf8.parse(this.secretKey);
        const bytes = crypto_js_1.default.AES.decrypt(crypto_js_1.default.lib.CipherParams.create({
            ciphertext: dec,
            key: keyWA,
            algorithm: crypto_js_1.default.algo.AES,
            padding: crypto_js_1.default.pad.Pkcs7,
            formatter: crypto_js_1.default.format.Hex,
        }), keyWA, {
            mode: crypto_js_1.default.mode.ECB,
        });
        return JSON.parse(bytes.toString(crypto_js_1.default.enc.Utf8));
    }
}
exports.Auth = Auth;
//# sourceMappingURL=auth.js.map