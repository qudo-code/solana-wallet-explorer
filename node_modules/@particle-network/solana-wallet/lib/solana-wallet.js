"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaWallet = void 0;
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = __importDefault(require("bs58"));
const buffer_1 = require("buffer");
class SolanaWallet {
    constructor(auth, rpcUrl) {
        this.auth = auth;
        this.rpcUrl = rpcUrl;
        this.isParticleNetwork = true;
        this.auth = auth;
        this.rpcUrl = rpcUrl;
        this._connecting = false;
        const userInfo = this.auth.userInfo();
        if (userInfo) {
            const wallet = userInfo.wallets.find((w) => w.chain_name === "solana" && w.public_address.length > 0);
            if (wallet) {
                this._publicKey = new web3_js_1.PublicKey(wallet.public_address);
            }
            else {
                this._publicKey = null;
            }
        }
        else {
            this._publicKey = null;
        }
        this.auth.on("connect", (userInfo) => {
            const wallet = userInfo.wallets.find((w) => w.chain_name === "solana" && w.public_address.length > 0);
            if (wallet) {
                this._publicKey = new web3_js_1.PublicKey(wallet.public_address);
            }
        });
        this.auth.on("disconnect", () => {
            this._publicKey = null;
        });
    }
    get connecting() {
        return this._connecting;
    }
    get connected() {
        return this._publicKey !== null;
    }
    get publicKey() {
        return this._publicKey;
    }
    connect(config) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this._connecting = true;
                let wallet = this.auth.wallet();
                if (wallet) {
                    this._publicKey = new web3_js_1.PublicKey(wallet.public_address);
                    return Promise.resolve();
                }
                yield this.auth.login(config);
                wallet = this.auth.wallet();
                if (wallet) {
                    this._publicKey = new web3_js_1.PublicKey(wallet.public_address);
                    return Promise.resolve();
                }
                else {
                    return Promise.reject("wallet create failed");
                }
            }
            catch (e) {
                return Promise.reject(e);
            }
            finally {
                this._connecting = false;
            }
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.auth.logout();
            this._publicKey = null;
            return Promise.resolve();
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const signature = yield this.auth.sign("signTransaction", bs58_1.default.encode(transaction.serialize({ requireAllSignatures: false, verifySignatures: false })));
            return web3_js_1.Transaction.from(buffer_1.Buffer.from(signature, "base64"));
        });
    }
    signAllTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            const signatures = yield this.auth.signAllTransactions(transactions.map((tx) => bs58_1.default.encode(tx.serialize({ requireAllSignatures: false, verifySignatures: false }))));
            return signatures.map((signed) => web3_js_1.Transaction.from(buffer_1.Buffer.from(signed, "base64")));
        });
    }
    signAndSendTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.auth.sendTransaction(bs58_1.default.encode(transaction.serialize({ requireAllSignatures: false, verifySignatures: false })));
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const signature = yield this.auth.sign("signMessage", bs58_1.default.encode(message));
            return buffer_1.Buffer.from(signature, "base64");
        });
    }
    getConnection(config) {
        const url = this.rpcUrl ? this.rpcUrl + "/solana/rpc" : "https://api.particle.network/solana-chain/rpc";
        return new web3_js_1.Connection(`${url}?chainId=${this.auth.chainId()}`, {
            commitment: config === null || config === void 0 ? void 0 : config.commitment,
            wsEndpoint: config === null || config === void 0 ? void 0 : config.wsEndpoint,
            httpHeaders: {
                Authorization: this.auth.basicCredentials(),
            },
            fetch: config === null || config === void 0 ? void 0 : config.fetch,
            fetchMiddleware: config === null || config === void 0 ? void 0 : config.fetchMiddleware,
            disableRetryOnRateLimit: config === null || config === void 0 ? void 0 : config.disableRetryOnRateLimit,
            confirmTransactionInitialTimeout: config === null || config === void 0 ? void 0 : config.confirmTransactionInitialTimeout,
        });
    }
}
exports.SolanaWallet = SolanaWallet;
//# sourceMappingURL=solana-wallet.js.map