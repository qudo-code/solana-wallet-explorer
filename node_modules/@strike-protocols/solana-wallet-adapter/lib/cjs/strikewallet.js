"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StrikeWallet = void 0;
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = __importDefault(require("bs58"));
const uuid_1 = require("uuid");
const DEFAULT_SIGNATURE_BUFFER = Buffer.alloc(web3_js_1.SIGNATURE_LENGTH_IN_BYTES).fill(0);
class StrikeWallet {
    constructor() {
        this.url = 'https://wallet.strikeprotocols.com';
        this.cleanUp = () => {
            [...this._timers].forEach(t => this.clearTimer(t));
            const wallet = this._wallet;
            if (wallet) {
                wallet.close();
            }
            this._wallet = null;
        };
        this.clearTimer = (timer) => {
            this._timers = this._timers.filter(t => t != timer);
            window.clearInterval(timer);
        };
        this.instructionsToSerializableInstructions = (instructions) => instructions.map(i => {
            return {
                'programId': i.programId.toBase58(),
                'accountMetas': i.keys.map(k => {
                    return {
                        address: k.pubkey.toBase58(),
                        signer: k.isSigner,
                        writable: k.isWritable,
                    };
                }),
                'data': window.btoa(String.fromCharCode(...i.data)),
            };
        });
        this.handleWalletMessage = (data) => {
            var _a, _b, _c;
            if (data.type == "connected") {
                this._connecting = false;
                if (!data.error) {
                    this.isLoggedIn = true;
                    if ((_a = data.connected) === null || _a === void 0 ? void 0 : _a.publicKey) {
                        this._publicKey = new web3_js_1.PublicKey(data.connected.publicKey);
                    }
                }
            }
            else if (["sendTransaction", "sendFinalTransaction"].includes(data.type)) {
                const transactionIdentifier = (_b = data.sendTransaction) === null || _b === void 0 ? void 0 : _b.identifier;
                if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {
                    if (data.error) {
                        this._pendingTransactionErrors[transactionIdentifier] = { message: data.error };
                    }
                    else {
                        this._pendingTransactions[transactionIdentifier] = data.sendTransaction || null;
                    }
                }
            }
            else if (data.type == "signTransaction") {
                const transactionIdentifier = (_c = data.signTransaction) === null || _c === void 0 ? void 0 : _c.identifier;
                if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {
                    if (data.error) {
                        this._pendingTransactionErrors[transactionIdentifier] = { message: data.error };
                    }
                    else {
                        this._pendingTransactions[transactionIdentifier] = data.signTransaction || null;
                    }
                }
            }
        };
        this.isLoggedIn = false;
        this._pendingTransactions = {};
        this._pendingTransactionErrors = {};
        this._timers = [];
        this._wallet = null;
        this._connecting = false;
        this._publicKey = null;
        window.addEventListener("message", (e) => {
            this.handleWalletMessage(e.data);
        });
    }
    connect(url) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.url = url || this.url;
                const origin = encodeURIComponent(window.location.origin);
                const connectUrl = `${this.url}/connect?origin=${origin}`;
                this._connecting = true;
                this._wallet = window.open(connectUrl, `strike-wallet-${origin}`, "height=800,width=800,menubar=no,status=no,toolbar=no");
                if (!this._wallet) {
                    this._connecting = false;
                    throw new Error("Unable to connect to wallet");
                }
                this._timers.push(window.setInterval(() => {
                    if (this._wallet.closed) {
                        this.cleanUp();
                    }
                    else if (this._wallet) {
                        this._wallet.postMessage({ type: 'heartbeat' }, this.url);
                    }
                }, 100));
                return new Promise((resolve, reject) => {
                    const timer = window.setInterval(() => {
                        if (this.isLoggedIn && this._publicKey) {
                            this.clearTimer(timer);
                            resolve(this._publicKey);
                        }
                        else if (!this.isLoggedIn && !this._connecting) {
                            this.clearTimer(timer);
                            reject(new Error("Unable to connect to Strike"));
                        }
                    }, 100);
                    this._timers.push(timer);
                });
            }
            catch (error) {
                throw error;
            }
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            this.verifyCanSignRequests([transaction]);
            try {
                return this.signOneTransaction(transaction);
            }
            catch (error) {
                throw error;
            }
        });
    }
    signAllTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            this.verifyCanSignRequests(transactions);
            try {
                return this.signMultipleTransactions(transactions);
            }
            catch (error) {
                throw error;
            }
        });
    }
    sendTransaction(transaction, connection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const wallet = this._wallet;
                if (!wallet)
                    throw new Error("Not Connected");
                const transactionIdentifier = (0, uuid_1.v4)();
                this._pendingTransactions[transactionIdentifier] = null;
                const signers = options ? options.signers : undefined;
                if (signers && signers.length > 0) {
                    return new Promise((resolve, reject) => {
                        this.signOneTransaction(transaction, transactionIdentifier).then(walletTransaction => {
                            this._pendingTransactions[transactionIdentifier] = null;
                            (signers === null || signers === void 0 ? void 0 : signers.length) && walletTransaction.partialSign(...signers);
                            wallet.postMessage({
                                type: "sendFinalTransaction", sendFinalTransaction: {
                                    transactionIdentifier,
                                    signaturePubkeyPairs: walletTransaction.signatures.filter(sp => sp.signature != null).map(sp => {
                                        return {
                                            'pubkey': sp.publicKey.toBase58(),
                                            'signature': sp.signature.toString('base64')
                                        };
                                    })
                                }
                            }, this.url);
                            const timer = window.setInterval(() => {
                                const pendingTransaction = this._pendingTransactions[transactionIdentifier];
                                const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];
                                if (pendingTransaction != null || pendingTransactionError != null) {
                                    this.clearTimer(timer);
                                    pendingTransaction && resolve(pendingTransaction.signature);
                                    pendingTransactionError && reject(pendingTransactionError);
                                }
                            }, 100);
                            this._timers.push(timer);
                        }).catch((error) => {
                            reject(error);
                            throw error;
                        });
                    });
                }
                else {
                    const instructions = this.instructionsToSerializableInstructions(transaction.instructions);
                    return new Promise((resolve, reject) => {
                        wallet.postMessage({
                            type: "sendTransaction",
                            sendTransaction: { instructions, transactionIdentifier }
                        }, this.url);
                        const timer = window.setInterval(() => {
                            const pendingTransaction = this._pendingTransactions[transactionIdentifier];
                            const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];
                            if (pendingTransaction != null || pendingTransactionError != null) {
                                this.clearTimer(timer);
                                pendingTransaction && resolve(pendingTransaction.signature);
                                pendingTransactionError && reject(pendingTransactionError);
                            }
                        }, 100);
                        this._timers.push(timer);
                    });
                }
            }
            catch (error) {
                throw error;
            }
        });
    }
    buildTransaction(pendingTransaction) {
        let message = web3_js_1.Message.from(Buffer.from(Uint8Array.from(window.atob(pendingTransaction.message), c => c.charCodeAt(0))));
        return web3_js_1.Transaction.populate(message, Array.from({ length: message.header.numRequiredSignatures }, (_v, i) => {
            let sigPubkeyPair = pendingTransaction.signatures.find(s => s.pubkey == message.accountKeys[i].toBase58());
            return bs58_1.default.encode(sigPubkeyPair
                ? Buffer.from(Uint8Array.from(window.atob(sigPubkeyPair.signature), c => c.charCodeAt(0)))
                : DEFAULT_SIGNATURE_BUFFER);
        }));
    }
    verifyCanSignRequests(transactions) {
        transactions.forEach(transaction => {
            if (transaction.signatures.some(s => s.signature != null)) {
                throw new Error("Strike does not support this signing mode");
            }
        });
    }
    signOneTransaction(transaction, transactionIdentifier = (0, uuid_1.v4)()) {
        const wallet = this._wallet;
        if (!wallet)
            throw new Error("Not Connected");
        const instructions = this.instructionsToSerializableInstructions(transaction.instructions);
        this._pendingTransactions[transactionIdentifier] = null;
        return new Promise((resolve, reject) => {
            wallet.postMessage({ type: "signTransaction", signTransaction: { instructions, transactionIdentifier } }, this.url);
            const timer = window.setInterval(() => {
                const pendingTransaction = this._pendingTransactions[transactionIdentifier];
                const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];
                if (pendingTransaction != null || pendingTransactionError != null) {
                    this.clearTimer(timer);
                    pendingTransaction && resolve(this.buildTransaction(pendingTransaction));
                    pendingTransactionError && reject(pendingTransactionError);
                }
            }, 100);
            this._timers.push(timer);
        });
    }
    signMultipleTransactions(transactions) {
        const wallet = this._wallet;
        if (!wallet)
            throw new Error("Not Connected");
        const serializedTransactions = transactions.map((t) => {
            return {
                instructions: this.instructionsToSerializableInstructions(t.instructions),
                transactionIdentifier: (0, uuid_1.v4)()
            };
        });
        const transactionIdentifiers = serializedTransactions.map((t) => t.transactionIdentifier);
        transactionIdentifiers.forEach((transactionIdentifier) => this._pendingTransactions[transactionIdentifier] = null);
        return new Promise((resolve, reject) => {
            wallet.postMessage({ type: "signAllTransactions", signAllTransactions: { transactions: serializedTransactions } }, this.url);
            const timer = window.setInterval(() => {
                const pendingTransactions = transactionIdentifiers.map((txId) => this._pendingTransactions[txId]);
                const pendingTransactionErrors = transactionIdentifiers.map((txId) => this._pendingTransactionErrors[txId]);
                if (pendingTransactions.every((t) => t != null)) {
                    this.clearTimer(timer);
                    resolve(pendingTransactions.map((pt) => this.buildTransaction(pt)));
                }
                else if (pendingTransactionErrors.some((e) => e != null)) {
                    this.clearTimer(timer);
                    reject(pendingTransactionErrors.find((e) => e != null));
                }
            }, 100);
            this._timers.push(timer);
        });
    }
}
exports.StrikeWallet = StrikeWallet;
//# sourceMappingURL=strikewallet.js.map