/// <reference types="node" />
import EventEmmiter from "events";
import { Logger } from "pino";
import { IEngine } from "./engine";
import { IPairing } from "./pairing";
import { IProposal, ProposalTypes } from "./proposal";
import { ISession, SessionTypes } from "./session";
import { IJsonRpcHistory } from "../core/history";
import { CoreTypes, ICore } from "../core/core";
import { IExpirer } from "./expirer";
export declare namespace SignClientTypes {
    type Event = "session_proposal" | "session_update" | "session_extend" | "session_ping" | "pairing_ping" | "session_delete" | "pairing_delete" | "session_expire" | "pairing_expire" | "session_request" | "session_event" | "proposal_expire";
    interface BaseEventArgs<T = unknown> {
        id: number;
        topic: string;
        params: T;
    }
    interface EventArguments {
        session_proposal: Omit<BaseEventArgs<ProposalTypes.Struct>, "topic">;
        session_update: BaseEventArgs<{
            namespaces: SessionTypes.Namespaces;
        }>;
        session_extend: Omit<BaseEventArgs, "params">;
        session_ping: Omit<BaseEventArgs, "params">;
        pairing_ping: Omit<BaseEventArgs, "params">;
        session_delete: Omit<BaseEventArgs, "params">;
        pairing_delete: Omit<BaseEventArgs, "params">;
        session_expire: {
            topic: string;
        };
        pairing_expire: {
            topic: string;
        };
        session_request: BaseEventArgs<{
            request: {
                method: string;
                params: any;
            };
            chainId: string;
        }>;
        session_event: BaseEventArgs<{
            event: {
                name: string;
                data: any;
            };
            chainId: string;
        }>;
        proposal_expire: {
            id: number;
        };
    }
    type Metadata = {
        name: string;
        description: string;
        url: string;
        icons: string[];
    };
    interface Options extends CoreTypes.Options {
        core?: ICore;
        metadata?: Metadata;
    }
}
export declare abstract class ISignClientEvents extends EventEmmiter {
    constructor();
    abstract emit: <E extends SignClientTypes.Event>(event: E, args: SignClientTypes.EventArguments[E]) => boolean;
    abstract on: <E extends SignClientTypes.Event>(event: E, listener: (args: SignClientTypes.EventArguments[E]) => any) => this;
    abstract once: <E extends SignClientTypes.Event>(event: E, listener: (args: SignClientTypes.EventArguments[E]) => any) => this;
    abstract off: <E extends SignClientTypes.Event>(event: E, listener: (args: SignClientTypes.EventArguments[E]) => any) => this;
    abstract removeListener: <E extends SignClientTypes.Event>(event: E, listener: (args: SignClientTypes.EventArguments[E]) => any) => this;
}
export declare abstract class ISignClient {
    opts?: SignClientTypes.Options | undefined;
    readonly protocol = "wc";
    readonly version = 2;
    abstract readonly name: string;
    abstract readonly context: string;
    abstract readonly metadata: SignClientTypes.Metadata;
    abstract core: ICore;
    abstract logger: Logger;
    abstract events: ISignClientEvents;
    abstract engine: IEngine;
    abstract pairing: IPairing;
    abstract session: ISession;
    abstract proposal: IProposal;
    abstract history: IJsonRpcHistory;
    abstract expirer: IExpirer;
    constructor(opts?: SignClientTypes.Options | undefined);
    abstract connect: IEngine["connect"];
    abstract pair: IEngine["pair"];
    abstract approve: IEngine["approve"];
    abstract reject: IEngine["reject"];
    abstract update: IEngine["update"];
    abstract extend: IEngine["extend"];
    abstract request: IEngine["request"];
    abstract respond: IEngine["respond"];
    abstract ping: IEngine["ping"];
    abstract emit: IEngine["emit"];
    abstract disconnect: IEngine["disconnect"];
    abstract find: IEngine["find"];
}
//# sourceMappingURL=client.d.ts.map